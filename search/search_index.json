{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Certificate Monitor"},{"location":"license/","text":"License \u00b6 MIT License Copyright (c) 2016-2022 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright (c) 2016-2022 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"certificate-authority/","text":"Certificate Authority \u00b6","title":"Certificate Authority"},{"location":"certificate-authority/#certificate-authority","text":"","title":"Certificate Authority"},{"location":"certificate-authority/configuration/","text":"Configuration \u00b6 After installation is completed, there are a number of values to configure: Email Notifications \u00b6 Using sendmail configuration. \u00b6 Configure driver and sendmail in config/mail.php : 'driver' => env('MAIL_DRIVER', 'smtp'), 'sendmail' => '/usr/bin/sendmail -t', Using msmtp daemon. \u00b6 Configure driver and sendmail in config/mail.php : 'driver' => env('MAIL_DRIVER', 'smtp'), 'sendmail' => '/usr/bin/msmtp -C /etc/msmtprc -a default -t', Cache \u00b6 Logging \u00b6","title":"Configuration"},{"location":"certificate-authority/configuration/#configuration","text":"After installation is completed, there are a number of values to configure:","title":"Configuration"},{"location":"certificate-authority/configuration/#email-notifications","text":"","title":"Email Notifications"},{"location":"certificate-authority/configuration/#using-sendmail-configuration","text":"Configure driver and sendmail in config/mail.php : 'driver' => env('MAIL_DRIVER', 'smtp'), 'sendmail' => '/usr/bin/sendmail -t',","title":"Using sendmail configuration."},{"location":"certificate-authority/configuration/#using-msmtp-daemon","text":"Configure driver and sendmail in config/mail.php : 'driver' => env('MAIL_DRIVER', 'smtp'), 'sendmail' => '/usr/bin/msmtp -C /etc/msmtprc -a default -t',","title":"Using msmtp daemon."},{"location":"certificate-authority/configuration/#cache","text":"","title":"Cache"},{"location":"certificate-authority/configuration/#logging","text":"","title":"Logging"},{"location":"certificate-authority/customization/","text":"Customization \u00b6","title":"Customization"},{"location":"certificate-authority/customization/#customization","text":"","title":"Customization"},{"location":"certificate-authority/installation/","text":"Overview \u00b6 It aims to simplify the management of the Digital Certificates Lifecycle such as creation,renewal and revocation of keypairs (csr, private and private keys), signing of csr files created in external systems as well as generating csr by your own private CA. It also includes tools to generate of PFX/P12 archive, keymatch , expiry notifications , converter , decode and more... Installation \u00b6 Git recommended \u00b6 Certificate Authority Management Console can be downloaded with git : Clone repository: cd /var/www git clone https://github.com/lopeaa/ca-mgmt-console.git sudo chown -R $www -data:www-data /var/www/ca-mgmt-console sudo chmod -R 755 /var/www/ca-mgmt-console Modify .env database parameters: cd ca-mgmt-console mv .env.example .env nano .env Example database parameters: DB_CONNECTION = mysql DB_HOST = 127 .0.0.1 DB_PORT = 3306 DB_DATABASE = ca-mgmt-console DB_USERNAME = <username> DB_PASSWORD = <password> Update dependencies: composer update Create tables in database: php artisan migrate Download VM Image \u00b6 Download image","title":"Installation"},{"location":"certificate-authority/installation/#overview","text":"It aims to simplify the management of the Digital Certificates Lifecycle such as creation,renewal and revocation of keypairs (csr, private and private keys), signing of csr files created in external systems as well as generating csr by your own private CA. It also includes tools to generate of PFX/P12 archive, keymatch , expiry notifications , converter , decode and more...","title":"Overview"},{"location":"certificate-authority/installation/#installation","text":"","title":"Installation"},{"location":"certificate-authority/installation/#git","text":"Certificate Authority Management Console can be downloaded with git : Clone repository: cd /var/www git clone https://github.com/lopeaa/ca-mgmt-console.git sudo chown -R $www -data:www-data /var/www/ca-mgmt-console sudo chmod -R 755 /var/www/ca-mgmt-console Modify .env database parameters: cd ca-mgmt-console mv .env.example .env nano .env Example database parameters: DB_CONNECTION = mysql DB_HOST = 127 .0.0.1 DB_PORT = 3306 DB_DATABASE = ca-mgmt-console DB_USERNAME = <username> DB_PASSWORD = <password> Update dependencies: composer update Create tables in database: php artisan migrate","title":"Git"},{"location":"certificate-authority/installation/#download-vm-image","text":"Download image","title":"Download VM Image"},{"location":"certificate-authority/publishing/","text":"Publishing \u00b6 Nginx Webserver (HTTPS) \u00b6 Installation \u00b6 sudo apt update sudo apt install nginx Firewall rules: sudo ufw enable sudo ufw allow 'Nginx HTTPS' Check status: sudo ufw status Status: active To Action From -- ------ ---- OpenSSH ALLOW Anywhere Nginx HTTPS ALLOW Anywhere OpenSSH ( v6 ) ALLOW Anywhere ( v6 ) Nginx HTTPS ( v6 ) ALLOW Anywhere ( v6 ) Restart Nginx server sudo systemctl status nginx Configuration \u00b6 Prerequisites Nginx PHP Certbot ngxblocker (Optional) Example custom config Https /etc/nginx/sites-available/custom ## # Default server configuration # server { listen [::]:443 ssl http2 ipv6only=on; # managed by Certbot listen 443 ssl http2; # managed by Certbot ssl_certificate /etc/letsencrypt/live/domain.com/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/domain.com/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot server_name domain.com www.domain.com; root /var/www/html; ## # Nginx Bad Bot Blocker Includes # REPO: https://github.com/mitchellkrogza/nginx-ultimate-bad-bot-blocker ## include /etc/nginx/bots.d/ddos.conf; include /etc/nginx/bots.d/blockbots.conf; ## # Security headers ## add_header X-Frame-Options \"SAMEORIGIN\"; add_header Strict-Transport-Security \"max-age=31536000; includeSubdomains; preload\"; add_header Content-Security-Policy \"default-src 'self' http: https: data: blob: 'unsafe-inline'\" always; proxy_hide_header X-Powered-By; index index.php index.html; location / { limit_except GET HEAD POST { deny all; } try_files $uri $uri/ /index.php?$query_string; } error_page 404 /custom_404.html; location = /custom_404.html { root /usr/share/nginx/html; internal; } # pass PHP scripts to FastCGI server # location ~ \\.php$ { include snippets/fastcgi-php.conf; # With php-fpm (or other unix sockets): fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; # With php-cgi (or other tcp sockets): #fastcgi_pass 127.0.0.1:9000; } } Apache Webserver (HTTPS) \u00b6 Installation \u00b6 Configuration \u00b6 GitHub Pages \u00b6","title":"Publishing"},{"location":"certificate-authority/publishing/#publishing","text":"","title":"Publishing"},{"location":"certificate-authority/publishing/#nginx-webserver-https","text":"","title":"Nginx Webserver (HTTPS)"},{"location":"certificate-authority/publishing/#installation","text":"sudo apt update sudo apt install nginx Firewall rules: sudo ufw enable sudo ufw allow 'Nginx HTTPS' Check status: sudo ufw status Status: active To Action From -- ------ ---- OpenSSH ALLOW Anywhere Nginx HTTPS ALLOW Anywhere OpenSSH ( v6 ) ALLOW Anywhere ( v6 ) Nginx HTTPS ( v6 ) ALLOW Anywhere ( v6 ) Restart Nginx server sudo systemctl status nginx","title":"Installation"},{"location":"certificate-authority/publishing/#configuration","text":"Prerequisites Nginx PHP Certbot ngxblocker (Optional) Example custom config Https /etc/nginx/sites-available/custom ## # Default server configuration # server { listen [::]:443 ssl http2 ipv6only=on; # managed by Certbot listen 443 ssl http2; # managed by Certbot ssl_certificate /etc/letsencrypt/live/domain.com/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/domain.com/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot server_name domain.com www.domain.com; root /var/www/html; ## # Nginx Bad Bot Blocker Includes # REPO: https://github.com/mitchellkrogza/nginx-ultimate-bad-bot-blocker ## include /etc/nginx/bots.d/ddos.conf; include /etc/nginx/bots.d/blockbots.conf; ## # Security headers ## add_header X-Frame-Options \"SAMEORIGIN\"; add_header Strict-Transport-Security \"max-age=31536000; includeSubdomains; preload\"; add_header Content-Security-Policy \"default-src 'self' http: https: data: blob: 'unsafe-inline'\" always; proxy_hide_header X-Powered-By; index index.php index.html; location / { limit_except GET HEAD POST { deny all; } try_files $uri $uri/ /index.php?$query_string; } error_page 404 /custom_404.html; location = /custom_404.html { root /usr/share/nginx/html; internal; } # pass PHP scripts to FastCGI server # location ~ \\.php$ { include snippets/fastcgi-php.conf; # With php-fpm (or other unix sockets): fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; # With php-cgi (or other tcp sockets): #fastcgi_pass 127.0.0.1:9000; } }","title":"Configuration"},{"location":"certificate-authority/publishing/#apache-webserver-https","text":"","title":"Apache Webserver (HTTPS)"},{"location":"certificate-authority/publishing/#installation_1","text":"","title":"Installation"},{"location":"certificate-authority/publishing/#configuration_1","text":"","title":"Configuration"},{"location":"certificate-authority/publishing/#github-pages","text":"","title":"GitHub Pages"},{"location":"certificate-authority/api/","text":"API \u00b6","title":"API"},{"location":"certificate-authority/api/#api","text":"","title":"API"},{"location":"certificate-authority/code-snippets/controllers/","text":"Certificate Authority Controllers \u00b6 AuthenticodeController \u00b6 app/Http/Controllers/Admin/AuthenticodeController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use App\\Http\\Requests\\MassDestroyCertificateRequest; use App\\Http\\Requests\\StoreCertificateRequest; use App\\Http\\Requests\\UpdateCertificateRequest; use App\\Cert; class AuthenticodeController extends Controller { public function index() { abort_unless(\\Gate::allows('certificate_access'), 403); $certsNumber = Cert::all()->count(); $certs = Cert::all(); $certs_status_blank = Cert::where('status', '=', null)->count(); $certs_status_valid = Cert::where('status', '=', 'Valid')->count(); $certs_status_expiring = Cert::where('status', '=', 'Expiring')->count(); $certs_status_expired = Cert::where('status', '=', 'Expired')->count(); $certs_status_revoked = Cert::where('status', '=', 'Revoked')->count(); //dd($certs); return view('admin.certs.index', compact('certs', 'certsNumber', 'certs_status_blank', 'certs_status_valid', 'certs_status_expiring', 'certs_status_expired', 'certs_status_revoked')); } public function create() { abort_unless(\\Gate::allows('certificate_create'), 403); return view('admin.certs.create'); } public function store(StoreCertificateRequest $request) { abort_unless(\\Gate::allows('certificate_create'), 403); $cert = Cert::create($request->all()); return redirect()->route('admin.certs.index'); } public function edit(Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); return view('admin.certs.edit', compact('cert')); } public function update(UpdateCertificateRequest $request, Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); $cert->update($request->all()); return redirect()->route('admin.certs.index'); } public function show(Cert $cert) { abort_unless(\\Gate::allows('certificate_show'), 403); return view('admin.certs.show', compact('cert')); } public function destroy(Cert $cert) { abort_unless(\\Gate::allows('certificate_delete'), 403); $cert->delete(); return back(); } public function massDestroy(MassDestroyCertificateRequest $request) { Cert::whereIn('id', request('ids'))->delete(); return response(null, 204); } } CertificatesController \u00b6 app/Http/Controllers/Admin/CertificatesController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use App\\Http\\Requests\\MassDestroyCertificateKeyPair; use App\\Http\\Requests\\StoreCertificateKeyPair; use App\\Http\\Requests\\UpdateCertificate; use App\\Exceptions\\WrongCaKeyPasswordException; use Spatie\\SslCertificate\\SslCertificate; //use RealRashid\\SweetAlert\\Facades\\Alert; use App\\Cert; use App\\Params; use File; use ZipArchive; use Carbon\\Carbon; class CertificatesController extends Controller { public function index() { abort_unless(\\Gate::allows('certificate_access'), 403); $certsNumber = Cert::all()->count(); $certs = Cert::all(); /** Recalculate the expiry date and update */ foreach ($certs as $cert) { $id = $cert->id; /** calculate days diff between cert and today and update DB. */ if ($cert->validTo_time_t != null){ $certificate = SslCertificate::createFromString($cert->publicKey); //$today = Carbon::today(); $validToDate = $certificate->expirationDate(); $expiryDate = (string)$validToDate->diffInDays(today(), false); $isValid = $certificate->isValid(); $isExpired = $certificate->isExpired(); /** Calculate days to expire. */ $isExpiringInterval = $validToDate->copy()->subDays(60); $isExpiring = today()->isBetween($isExpiringInterval, $validToDate); /** Update diff in day. */ Cert::where('id', $id)->update(['expiryDate' => $expiryDate]); } if (empty($cert->publicKey)){ $status = null; Cert::where('id', $id)->update(['status' => $status]); } elseif ($isExpired === true) { $status = 'Expired'; Cert::where('id', $id)->update(['status' => $status ]); /** Ones cert is expired, it is deleted so that it is not scan with expiry check script. */ FILE::delete(storage_path('archives/keypairs/' . $id . '.zip')); FILE::delete(storage_path('archives/monitor/' . $id . '.cer')); FILE::delete(storage_path('archives/p12/' . $id . '.p12')); } elseif ($isExpiring === true && $cert->status != 'Revoked'){ $status = 'Expiring'; Cert::where('id', $id)->update(['status' => $status]); } elseif ($cert->status === 'Revoked'){ $status = 'Revoked'; Cert::where('id', $id)->update(['status' => $status]); } elseif ($isValid === true){ $status = 'Valid'; Cert::where('id', $id)->update(['status' => $status]); } else { $status = $cert->status; Cert::where('id', $id)->update(['status' => $status]); } } /** Chart */ $certs_status_blank = Cert::where('status', '=', null)->count(); $certs_status_valid = Cert::where('status', '=', 'Valid')->count(); $certs_status_expiring = Cert::where('status', '=', 'Expiring')->count(); $certs_status_expired = Cert::where('status', '=', 'Expired')->count(); $certs_status_revoked = Cert::where('status', '=', 'Revoked')->count(); return view('admin.certs.index', compact('certs', 'certsNumber', 'certs_status_blank', 'certs_status_valid', 'certs_status_expiring', 'certs_status_expired', 'certs_status_revoked' )); } public function create() { abort_unless(\\Gate::allows('certificate_create'), 403); $params = Params::all(); return view('admin.certs.new-cert.create', compact('params')); } public function store(StoreCertificateKeyPair $request) { abort_unless(\\Gate::allows('certificate_create'), 403); /** Separate CN and SANs. */ $commonName = explode(\";\", $request->subjectCommonName); $subjectCommonName = $commonName[0]; $extensionsSubjectAltName = explode(\",\", (\"DNS:\".implode(\",DNS:\", $commonName))); $extensionsSubjectAltName = implode(\",\", $extensionsSubjectAltName); /** Configuration file. */ $config = '/usr/lib/ssl/openssl.cnf'; /** Data needed to populate the certificate signed by this CA. email can\u00b4t be empty so if it is empty \"emailAddress\" is not included. */ if($request->email != ''){ $dn = array( \"countryName\" => 'ES', \"stateOrProvinceName\" => 'Madrid', \"localityName\" => 'Madrid', \"organizationName\" => $request->subjectOrganization, \"organizationalUnitName\" => $organizationUnitName, \"commonName\" => $subjectCommonName, \"emailAddress\" => $request->email ); } else { $dn = array( \"countryName\" => 'ES', \"stateOrProvinceName\" => 'Madrid', \"localityName\" => 'Madrid', \"organizationName\" => $request->subjectOrganization, \"organizationalUnitName\" => $organizationUnitName, \"commonName\" => $subjectCommonName //\"emailAddress\" => null ); } /** Clean DNS entries. */ shell_exec(\"sudo /opt/subjectAltNameRemoval.sh 2>&1\"); /** Clear DNS entries script. */ $configFile = file_get_contents($config); $configFile = str_replace(\"DNS:\", $extensionsSubjectAltName, $configFile); /** Do replacements. */ file_put_contents($config, $configFile); unset($configFile); /** Arguments to be passed to the CSR. */ $configArgs = array( 'config' => $config, 'encrypt_key' => false, 'private_key_type' => OPENSSL_KEYTYPE_RSA, 'subjectAltName' => $request->extensionsSubjectAltName, 'digest_alg' => $request->signatureTypeSN ); /** Generate REQ and his corresponding Private Key. */ $reqgen = openssl_csr_new($dn, $keygen, $configArgs); /** Export Private Key to string and save it to disk. */ openssl_pkey_export($keygen, $privateKey); /** Export CSR to string and save it to disk. */ openssl_csr_export($reqgen, $certificateServerRequest); /** Signing CSR. Location of CA Pub/Priv certificates. */ $cacert = file_get_contents('/opt/ca/cacert.pem'); $pkeyid = array(file_get_contents('/opt/ca/private/cakey.pem'), $request->password ); $configArgs = array( 'config' => $config, 'encrypt_key' => false, 'private_key_bits' => (int)$request->keyLength, 'private_key_type' => OPENSSL_KEYTYPE_RSA, 'digest_alg' => $request->signatureTypeSN, 'x509_extensions' => $request->extensionsExtendedKeyUsage); /** Insert serial number. */ $serialNumber = random_int(160000000001, 170000000001); /** Sign Certificate Server Request. */ $certgen = openssl_csr_sign($certificateServerRequest , $cacert, $pkeyid, $request->validityPeriod, $configArgs, $serialNumber); /** Export signed certificate to string variable and save it to disk. */ openssl_x509_export($certgen, $publicKey); /** Clean SAN DNS entries. */ shell_exec(\"sudo /opt/subjectAltNameRemoval.sh 2>&1\"); /** Parse certificate data. */ $certParser = openssl_x509_parse($publicKey); /** Include certificate parse data in request. */ $request['subjectCommonName'] = $certParser['subject']['CN']; $request['subjectContry'] = $certParser['subject']['C']; $request['subjectState'] = $certParser['subject']['ST']; $request['subjectOrganization'] = $certParser['subject']['O']; $request['subjectOrganizationUnit'] = $certParser['subject']['OU']; $request['hash'] = $certParser['hash']; $request['issuerCN'] = $certParser['issuer']['CN']; $request['issuerOrganization'] = $certParser['issuer']['O']; $request['issuerOrganizationUnit'] = $certParser['issuer']['OU']; $request['version'] = $certParser['version']; $request['serialNumber'] = $serialNumber; //$request['serialNumberHex'] = $serialNumberHex; $request['validFrom'] = $certParser['validFrom']; $request['validTo'] = $certParser['validTo']; $request['validFrom_time_t'] = $certParser['validFrom_time_t']; $request['validTo_time_t'] = $certParser['validTo_time_t']; $request['signatureTypeSN'] = $certParser['signatureTypeSN']; $request['signatureTypeLN'] = $certParser['signatureTypeLN']; $request['signatureTypeNID'] = $certParser['signatureTypeNID']; $request['purposes'] = null; // to be implemented. $request['extensionsBasicConstraints'] = $certParser['extensions']['basicConstraints']; $request['extensionsKeyUsage'] = $certParser['extensions']['keyUsage']; $request['extensionsExtendedKeyUsage'] = $certParser['extensions']['extendedKeyUsage']; $request['extensionsSubjectKeyIdentifier'] = $certParser['extensions']['subjectKeyIdentifier']; $request['extensionsAuthorityKeyIdentifier'] = $certParser['extensions']['authorityKeyIdentifier']; $request['extensionsSubjectAltName'] = $certParser['extensions']['subjectAltName']; $request['extensionsCrlDistributionPoints'] = $certParser['extensions']['crlDistributionPoints']; $request['certificateServerRequest'] = $certificateServerRequest; $request['publicKey'] = $publicKey; $request['privateKey'] = $privateKey; $request['status'] = 'Valid'; $request['p12'] = null; /** Convert dates. */ $validTo_time_t = date(DATE_RFC2822, $certParser['validTo_time_t']); $expiryDate = Carbon::parse(Carbon::now())->diffInDays($validTo_time_t); $request['expiryDate'] = $expiryDate; $cert = Cert::create($request->all()); $cert->save(); $cert = Cert::where('subjectCommonName', $subjectCommonName)->get()->last(); file_put_contents(storage_path('archives/tmp/' . $cert->id . '.key'), $privateKey); file_put_contents(storage_path('archives/tmp/' . $cert->id .'.cer'), $publicKey); file_put_contents(storage_path('archives/tmp/' . $cert->id . '.csr'), $certificateServerRequest); /** If Monitor check enabled, include in /opt/certmon/ json. * Possible solution is to trigger the e-mail or just include the json data in the files. */ /** end include in certmon */ file_put_contents(storage_path('archives/monitor/' . $cert->id . '.cer'), $publicKey); /** Zip the .cer and .key saved in storage_path/tmp and move it to storage_path/archives. then, delete files. */ $zipFile = $cert->id . '.zip'; $zip = new ZipArchive(); $path = storage_path('archives/keypairs/'); $zip->open($path . $zipFile, ZipArchive::CREATE); //$files = new \\RecursiveIteratorIterator(new \\RecursiveDirectoryIterator($path)); $files = File::files(storage_path('archives/tmp/')); foreach ($files as $name => $file) { /** Skipping all subfolders */ if (!$file->isDir()) { $filePath = $file->getRealPath(); /** Extracting filename with substr/strlen */ $relativePath = '' . substr($filePath, strlen($path) -5); $zip->addFile($filePath, $relativePath); } } $zip->close(); File::delete(storage_path('archives/tmp/' . $cert->id . '.csr')); File::delete(storage_path('archives/tmp/' . $cert->id . '.cer')); File::delete(storage_path('archives/tmp/' . $cert->id . '.key')); //Alert::success('Certificate successfully created', 'Certificate keypair has been created', 'Success'); return redirect()->route('admin.certs.index')->with('success', 'Certificate keypair created successfully.'); } public function edit(Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); return view('admin.certs.edit', compact('cert')); } public function update(UpdateCertificate $request, Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); /** Make a Keymatch before updating. */ if ($request->filled(['certificateServerRequest','publicKey', 'privateKey']) && $cert->status != 'Revoked') { /** Check if PublicKey matches PrivateKey. */ $keyMatches = openssl_x509_check_private_key($request->input('publicKey'), $request->input('privateKey')); /** Check if CSR matches PublicKey. */ file_put_contents(storage_path('archives/tmp/') . 'csr.csr', $request->input('certificateServerRequest')); file_put_contents(storage_path('archives/tmp/') . 'cert.cer', $request->input('publicKey')); file_put_contents(storage_path('archives/tmp/') . 'key.key', $request->input('privateKey')); $certSHA2sum = shell_exec(\"openssl x509 -in archives/tmp/cert.cer -pubkey -noout -outform pem | sha256sum 2>&1\"); $csrSHA2sum = shell_exec(\"openssl req -in archives/tmp/csr.csr -pubkey -noout -outform pem | sha256sum 2>&1\"); if($certSHA2sum === $csrSHA2sum && $keyMatches === true){ $cert->update($request->all('certificateServerRequest')); $cert->update($request->all('publicKey')); $cert->update($request->all('privateKey')); $cert->update($request->all('comments')); } else { File::delete(storage_path('archives/tmp/') . 'csr.csr'); File::delete(storage_path('archives/tmp/') . 'cert.cer'); File::delete(storage_path('archives/tmp/') . 'key.key'); return redirect()->route('admin.certs.index')->with('error', 'Certificate and Private key don\u00b4t match'); } /** Parse certificate data. */ $certParser = openssl_x509_parse($request->input('publicKey')); $request['subjectCommonName'] = $certParser['subject']['CN']; $request['subjectContry'] = $certParser['subject']['C']; //$request['subjectState'] = $certParser['subject']['ST']; $request['subjectOrganization'] = $certParser['subject']['O']; //$request['subjectOrganizationUnit'] = $certParser['subject']['OU']; $request['hash'] = $certParser['hash']; $request['issuerCN'] = $certParser['issuer']['CN']; $request['issuerOrganization'] = $certParser['issuer']['O']; //$request['issuerOrganizationUnit'] = $certParser['issuer']['OU']; $request['version'] = $certParser['version']; $request['serialNumber'] = $certParser['serialNumber']; $request['serialNumberHex'] = $certParser['serialNumberHex']; $request['validFrom'] = $certParser['validFrom']; $request['validTo'] = $certParser['validTo']; $request['validFrom_time_t'] = $certParser['validFrom_time_t']; $request['validTo_time_t'] = $certParser['validTo_time_t']; $request['signatureTypeSN'] = $certParser['signatureTypeSN']; $request['signatureTypeLN'] = $certParser['signatureTypeLN']; $request['signatureTypeNID'] = $certParser['signatureTypeNID']; $request['purposes'] = null; $request['extensionsBasicConstraints'] = $certParser['extensions']['basicConstraints']; $request['extensionsKeyUsage'] = $certParser['extensions']['keyUsage']; $request['extensionsExtendedKeyUsage'] = $certParser['extensions']['extendedKeyUsage']; $request['extensionsSubjectKeyIdentifier'] = $certParser['extensions']['subjectKeyIdentifier']; $request['extensionsAuthorityKeyIdentifier'] = $certParser['extensions']['authorityKeyIdentifier']; $request['extensionsSubjectAltName'] = $certParser['extensions']['subjectAltName']; $request['extensionsCrlDistributionPoints'] = $certParser['extensions']['crlDistributionPoints']; $request['certificateServerRequest'] = $request->input('certificateServerRequest'); $request['publicKey'] = $request->input('publicKey'); $request['privateKey'] = $request->input('privateKey'); $request['p12'] = null; /** Convert dates. */ $validTo_time_t = date(DATE_RFC2822, $certParser['validTo_time_t']); $expiryDate = Carbon::parse(Carbon::now())->diffInDays($validTo_time_t, false); /** in days */ $request['expiryDate'] = $expiryDate; /** Calculate status: Valid,Expiring, Expired. */ if($expiryDate > 0) { $request['status'] = 'Valid'; } elseif($expiryDate >= 90) { $request['status'] = 'Expiring'; } elseif($expiryDate < 0) { $request['status'] = 'Expired'; } $cert->update($request->all( 'subjectCommonName', 'subjectContry', //'subjectState', 'subjectOrganization', //'subjectOrganizationUnit', 'hash', 'issuerCN', 'issuerOrganization', //'issuerOrganizationUnit', 'version', 'serialNumber', 'serialNumberHex', 'validFrom', 'validTo', 'validFrom_time_t', 'validTo_time_t', 'expiryDate', 'signatureTypeSN', 'signatureTypeLN', 'signatureTypeNID', 'purposes', 'extensionsBasicConstraints', 'extensionsKeyUsage', 'extensionsExtendedKeyUsage', 'extensionsSubjectKeyIdentifier', 'extensionsSubjectAltName', 'extensionsSubjectAltName', 'extensionsCrlDistributionPoints', 'certificateServerRequest', 'publicKey', 'privateKey', 'status', 'p12', )); /** Include certificate to local monitor */ file_put_contents(storage_path('archives/monitor/' . $cert->id . '.cer'), $request->publicKey); /** Zip the .cer and .key saved in storage_path/tmp and move it to storage_path/archives. */ $zipFile = $cert->id . '.zip'; $zip = new ZipArchive(); $path = storage_path('archives/keypairs/'); $zip->open($path . $zipFile, ZipArchive::CREATE | ZipArchive::OVERWRITE); //$files = new \\RecursiveIteratorIterator(new \\RecursiveDirectoryIterator($path)); $files = File::files(storage_path('archives/tmp/')); foreach ($files as $name => $file) { /** Skipping all subfolders */ if (!$file->isDir()) { $filePath = $file->getRealPath(); /** extracting filename with substr/strlen */ $relativePath = '' . substr($filePath, strlen($path) -5); $zip->addFile($filePath, $relativePath); } } $zip->close(); /** Include certificate to local monitor */ file_put_contents(storage_path('archives/monitor/' . $cert->id . '.cer'), $request->publicKey); File::delete(storage_path('archives/tmp/') . 'csr.csr'); File::delete(storage_path('archives/tmp/') . 'cert.cer'); File::delete(storage_path('archives/tmp/') . 'key.key'); return redirect()->route('admin.certs.index')->with('success','Updated successfully.'); } elseif ($cert->status === 'Revoked'){ return redirect()->route('admin.certs.index')->with('error','Certificate is Revoked and can\u00b4t be updated.'); } else { //Alert::error('Error Updating', 'Data don\u00b4t match or has not been provided.', 'error')->persistent('close'); return redirect()->route('admin.certs.index')->with('error','Error updating. Check if public and private key matches.'); } } public function show(Cert $cert) { abort_unless(\\Gate::allows('certificate_show'), 403); /** Convert dates validFrom and validTo to show them properly in view. */ $certs = Cert::all(); $validFrom_time_t = date(DATE_RFC2822, $cert->validFrom_time_t); $validTo_time_t = date(DATE_RFC2822, $cert->validTo_time_t); $created_at = $cert->created_at; return view('admin.certs.show', compact( 'cert', 'validFrom_time_t', 'validTo_time_t', 'created_at' )); } public function destroy(Cert $cert) { abort_unless(\\Gate::allows('certificate_delete'), 403); $cert->delete(); /** Delete file from storage. This file is used by the local monitoring script */ //Alert::success('Deleted Successfully', 'All data related to this certificate has been deleted.', 'Success'); File::delete(storage_path('archives/monitor/' . $cert->id .'.cer')); File::delete(storage_path('archives/keypairs/' . $cert->id .'.zip')); return back(); } public function massDestroy(MassDestroyCertificateKeyPair $request) { Cert::whereIn('id', request('ids'))->delete(); return response(null, 204); } } ConverterController \u00b6 app/Http/Controllers/Admin/ConverterController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; use App\\Cert; class ConverterController extends Controller { /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function index() { // } /** * Show the form for creating a new resource. * * @return \\Illuminate\\Http\\Request * @return \\Illuminate\\Http\\Response */ public function create($id) { // } /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function store(Request $request) { $cert = Cert::where('id', $request->id)->get()->first(); $p12Args = array( 'friendly_name' => $cert->subjectCommonName, 'extracerts' => storage_path('archives/','cert.ca.cer') ); /** Export it to string format in order to insert it in database and to file to back it up in archives/p12/ */ openssl_pkcs12_export($cert->publicKey, $p12String, $cert->privateKey, $request->password, $p12Args); openssl_pkcs12_export_to_file($cert->publicKey, storage_path('archives/p12/' . $request->id . '.p12'), $cert->privateKey, $request->password, $p12Args); /** Update database field 'p12' */ Cert::where('id', $request->id)->update(['p12' => $p12String]); $headers = array('Content_Type: application/x-download',); return response()->download(storage_path('archives/p12/' . $request->id . '.p12'), $request->id . '.p12', $headers); } /** * Display the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function Show($id) { $cert = Cert::where('id', $id)->get()->first(); $subjectCommonName = $cert->subjectCommonName; if ($cert->publicKey == null OR $cert->privateKey == null){ return redirect()->route('admin.certs.index')->with('error','Keys not found. Check if Public and Private keys exist and match.'); } else { return view('admin.converter.show', compact('id', 'subjectCommonName')); } } /** * Show the form for editing the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function edit($id) { dd('Edit'); } /** * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request $request * @param int $id * @return \\Illuminate\\Http\\Response */ public function update(Request $request, $id) { dd('Update'); } /** * Remove the specified resource from storage. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function destroy($id) { dd('Destroy'); } } DownloadArchiveController \u00b6 app/Http/Controllers/Admin/DownloadArchiveController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Support\\Facades\\Response; class DownloadArchiveController extends Controller { function downloadArchive($id){ $headers = array('Content_Type: application/x-download'); return Response::download(storage_path('archives/keypairs/' . $id . '.zip'), $id . '.zip', $headers); } function downloadCA(){ $headers = array('Content_Type: application/x-download'); return Response::download(storage_path('archives/cert.ca.cer'), 'cert.ca.cer', $headers); } function downloadCRL(){ $headers = array('Content_Type: application/x-download'); return Response::download(storage_path('archives/ca-g2.crl'), 'ca-g2.crl', $headers); } } ImportController \u00b6 app/Http/Controllers/Admin/ImportController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Support\\Facades\\Response; use Illuminate\\Http\\Request; class ImportController extends Controller { /** * Display a listing of the resource. * * @return \\Illuminate\\Http\\Response */ public function index() { // Code } /** * Show the form for creating a new resource. * * @return \\Illuminate\\Http\\Response */ public function create(Request $request) { return view('admin.import.create'); } /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function store(Request $request) { // } /** * Display the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function show($id) { // } /** * Show the form for editing the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function edit($id) { // } /** * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request $request * @param int $id * @return \\Illuminate\\Http\\Response */ public function update(Request $request, $id) { // } /** * Remove the specified resource from storage. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function destroy($id) { // } } JarSignerController \u00b6 app/Http/Controllers/Admin/JarSignerController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use App\\Http\\Requests\\MassDestroyCertificateRequest; use App\\Http\\Requests\\StoreCertificateRequest; use App\\Http\\Requests\\UpdateCertificateRequest; use App\\Cert; class JarSignerController extends Controller { public function index() { abort_unless(\\Gate::allows('certificate_access'), 403); $certsNumber = Cert::all()->count(); $certs = Cert::all(); // Chart - Certificates status. $certs_status_blank = Cert::where('status', '=', null)->count(); $certs_status_valid = Cert::where('status', '=', 'Valid')->count(); $certs_status_expiring = Cert::where('status', '=', 'Expiring')->count(); $certs_status_expired = Cert::where('status', '=', 'Expired')->count(); $certs_status_revoked = Cert::where('status', '=', 'Revoked')->count(); //dd($certs); return view('admin.certs.index', compact('certs', 'certsNumber', 'certs_status_blank', 'certs_status_valid', 'certs_status_expiring', 'certs_status_expired', 'certs_status_revoked')); } public function create() { abort_unless(\\Gate::allows('certificate_create'), 403); return view('admin.certs.create'); } public function store(StoreCertificateRequest $request) { abort_unless(\\Gate::allows('certificate_create'), 403); $cert = Cert::create($request->all()); return redirect()->route('admin.certs.index'); } public function edit(Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); return view('admin.certs.edit', compact('cert')); } public function update(UpdateCertificateRequest $request, Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); $cert->update($request->all()); return redirect()->route('admin.certs.index'); } public function show(Cert $cert) { abort_unless(\\Gate::allows('certificate_show'), 403); return view('admin.certs.show', compact('cert')); } public function destroy(Cert $cert) { abort_unless(\\Gate::allows('certificate_delete'), 403); $cert->delete(); return back(); } public function massDestroy(MassDestroyCertificateRequest $request) { Cert::whereIn('id', request('ids'))->delete(); return response(null, 204); } } KeyMatcherCertificateController \u00b6 app/Http/Controllers/Admin/ConverterController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; use App\\Cert; class ConverterController extends Controller { /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function index() { // } /** * Show the form for creating a new resource. * * @return \\Illuminate\\Http\\Request * @return \\Illuminate\\Http\\Response */ public function create($id) { // } /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function store(Request $request) { $cert = Cert::where('id', $request->id)->get()->first(); $p12Args = array( 'friendly_name' => $cert->subjectCommonName, 'extracerts' => storage_path('archives/','cert.ca.cer') ); /** Export it to string format in order to insert it in database and to file to back it up in archives/p12/ */ openssl_pkcs12_export($cert->publicKey, $p12String, $cert->privateKey, $request->password, $p12Args); openssl_pkcs12_export_to_file($cert->publicKey, storage_path('archives/p12/' . $request->id . '.p12'), $cert->privateKey, $request->password, $p12Args); /** Update database field 'p12' */ Cert::where('id', $request->id)->update(['p12' => $p12String]); $headers = array('Content_Type: application/x-download',); return response()->download(storage_path('archives/p12/' . $request->id . '.p12'), $request->id . '.p12', $headers); } /** * Display the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function Show($id) { $cert = Cert::where('id', $id)->get()->first(); $subjectCommonName = $cert->subjectCommonName; if ($cert->publicKey == null OR $cert->privateKey == null){ return redirect()->route('admin.certs.index')->with('error','Keys not found. Check if Public and Private keys exist and match.'); } else { return view('admin.converter.show', compact('id', 'subjectCommonName')); } } /** * Show the form for editing the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function edit($id) { dd('Edit'); } /** * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request $request * @param int $id * @return \\Illuminate\\Http\\Response */ public function update(Request $request, $id) { dd('Update'); } /** * Remove the specified resource from storage. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function destroy($id) { dd('Destroy'); } } NewSigningRequestController \u00b6 app/Http/Controllers/Admin/KeyMatcherCertificateController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; use App\\Params; use App\\Cert; use File; class KeyMatcherCertificateController extends Controller { /** * Display a listing of the resource. * * @return \\Illuminate\\Http\\Response */ public function index() { // } /** * Show the form for creating a new resource. * * @return \\Illuminate\\Http\\Response */ public function create() { // } /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function store(Request $request) { // } /** * Display the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function show($id) { $params = Params::all(); $cert = Cert::where('id', $id)->get()->first(); $subjectCommonName = $cert->subjectCommonName; $extensionsSubjectAltName = $cert->extensionsSubjectAltName; /** Check if csr/cert/key are in DB. */ if($cert->certificateServerRequest != null){ $csr_status = 'Found'; } else { $csr_status = 'Not found'; } if($cert->publicKey != null){ $cert_status = 'Found'; } else { $cert_status = 'Not found'; } if($cert->privateKey != null){ $key_status = 'Found'; } else { $key_status = 'Not found'; } /** Checks if a private key matches certificate. */ $keyMatchesCert = openssl_x509_check_private_key($cert->publicKey, $cert->privateKey); if($keyMatchesCert === true){ $keyMatchesCert = 'YES'; } else { $keyMatchesCert = 'NO'; } file_put_contents(storage_path('archives/tmp/') . 'temp.csr', $cert->certificateServerRequest); file_put_contents(storage_path('archives/tmp/') . 'temp.cer', $cert->publicKey); $certSHA2sum = shell_exec(\"openssl x509 -in archives/tmp/temp.cer -pubkey -noout -outform pem | sha256sum 2>&1\"); $csrSHA2sum = shell_exec(\"openssl req -in archives/tmp/temp.csr -pubkey -noout -outform pem | sha256sum 2>&1\"); if($certSHA2sum === $csrSHA2sum){ $certMatchesCSR = 'YES'; } else { $certMatchesCSR = 'NO'; } File::delete(storage_path('archives/tmp/') . 'temp.csr'); File::delete(storage_path('archives/tmp/') . 'temp.cer'); return view('admin.keymatcher.show', compact( 'id', 'params', 'subjectCommonName', 'extensionsSubjectAltName', 'csr_status', 'cert_status', 'key_status', 'keyMatchesCert', 'certMatchesCSR', 'certSHA2sum', 'csrSHA2sum' )); } /** * Show the form for editing the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function edit($id) { // } /** * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request $request * @param int $id * @return \\Illuminate\\Http\\Response */ public function update(Request $request, $id) { // } /** * Remove the specified resource from storage. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function destroy($id) { // } } RenewCertificateController \u00b6 app/Http/Controllers/Admin/RenewCertificateController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; use App\\Cert; use App\\Params; use File; use ZipArchive; class RenewCertificateController extends Controller { /** * Display a listing of the resource. * * @return \\Illuminate\\Http\\Response */ public function index() { // } /** * Show the form for creating a new resource. * * @return \\Illuminate\\Http\\Response */ public function create() { // } /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function store(Request $request) { $cert = Cert::where('id', $request->id)->get()->first(); $config = '/usr/lib/ssl/openssl.cnf'; /** Clean DNS: entries in ca.cnf */ shell_exec(\"sudo /opt/subjectAltNameRemoval.sh 2>&1\"); /** Open ca.cnf, insert extensionsSubjectAltName and save ca.cnf */ $insertSAN = file_get_contents($config); $insertSAN = str_replace(\"DNS:\", $cert->extensionsSubjectAltName, $insertSAN); file_put_contents($config, $insertSAN); unset($insertSAN); /** Arguments pass to the CSR */ $configArgs = array( 'config' => $config, 'encrypt_key' => false, 'private_key_type' => OPENSSL_KEYTYPE_RSA, 'subjectAltName' => $cert->extensionsSubjectAltName, // Not needed since it is hardcoded (above) in config file. 'digest_alg' => $cert->signatureTypeSN, 'x509_extensions' => $cert->extensionsExtendedKeyUsage ); $serialNumber = random_int(160000000001, 170000000001); // serial for external CSR in Decimal format. $serialNumberHex = dechex($serialNumber); // serial for external CSR in Hexadecimal format. $cacert = file_get_contents('/opt/ca/cacert.pem'); $pkeyid = array(file_get_contents('/opt/ca/private/cakey.pem'), $request->password ); /** Sign csr from DB */ $csr_sign = openssl_csr_sign($cert->certificateServerRequest , $cacert, $pkeyid, $request->validityPeriod, $configArgs, $serialNumber); /** Export signed certificate to string variable. */ openssl_x509_export($csr_sign, $publicKey); /** Replace publickey for monitoring */ File::delete(storage_path('archives/monitor/' . $cert->id . '.cer')); file_put_contents(storage_path('archives/monitor/' . $cert->id . '.cer'), $publicKey); /** Update archive/keypairs archive with new certificate */ $zipFile = $cert->id . '.zip'; $zip = new ZipArchive(); $path = storage_path('archives/keypairs/'); $zip->open($path . $zipFile, ZipArchive::CREATE); //$files = new \\RecursiveIteratorIterator(new \\RecursiveDirectoryIterator($path)); $zip->addFile(storage_path('archives/monitor/' . $cert->id . '.cer'), $cert->id . '.cer'); $zip->close(); shell_exec(\"sudo /opt/subjectAltNameRemoval.sh 2>&1\"); /** Certificate parser */ $certParser = openssl_x509_parse($publicKey); /** DB updates */ Cert::where('id', $cert->id)->update(['expiryDate' => $request->validityPeriod]); Cert::where('id', $cert->id)->update(['serialNumber' => $serialNumber]); Cert::where('id', $cert->id)->update(['serialNumberHex' => $serialNumberHex]); Cert::where('id', $cert->id)->update(['publicKey' => $publicKey]); Cert::where('id', $cert->id)->update(['p12' => null]); Cert::where('id', $cert->id)->update(['validFrom' => $certParser['validFrom']]); Cert::where('id', $cert->id)->update(['validTo' => $certParser['validTo']]); Cert::where('id', $cert->id)->update(['validFrom_time_t' => $certParser['validFrom_time_t']]); Cert::where('id', $cert->id)->update(['validTo_time_t' => $certParser['validTo_time_t']]); Cert::where('id', $cert->id)->update(['hash' => $certParser['hash']]); Cert::where('id', $cert->id)->update(['extensionsSubjectKeyIdentifier' => $certParser['extensions']['subjectKeyIdentifier']]); Cert::where('id', $cert->id)->update(['extensionsAuthorityKeyIdentifier' => $certParser['extensions']['authorityKeyIdentifier']]); Cert::where('id', $cert->id)->update(['status' => 'Valid']); return redirect()->route('admin.certs.index')->with('success', \"Certificate successfully renewed.\"); } /** * Display the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function show($id) { $params = Params::all(); $cert = Cert::where('id', $id)->get()->first(); $subjectCommonName = $cert->subjectCommonName; $extensionsSubjectAltName = $cert->extensionsSubjectAltName; if ($cert->certificateServerRequest == null OR $cert->privateKey == null OR $cert->status == 'Revoked'){ return redirect()->route('admin.certs.index')->with('error',\"Keys not found. Check if Request (CSR) and Private keys exist and match OR if certificate is Revoked.\"); } elseif ($cert->issuerCN !== 'LIQUABit Root CA') { // Extract issuer from cert ca.cert.cert nad meke it dynamic. return redirect()->route('admin.certs.index')->with('error', \"Issuer mismatch. It seems that this certificate has been issued by: {$cert->issuerCN}\"); } else { return view('admin.renew.show', compact('id', 'params', 'subjectCommonName', 'extensionsSubjectAltName')); } } /** * Show the form for editing the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function edit($id) { // } /** * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request $request * @param int $id * @return \\Illuminate\\Http\\Response */ public function update(Request $request, $id) { // } /** * Remove the specified resource from storage. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function destroy($id) { // } } RevokeCertificateController \u00b6 app/Http/Controllers/Admin/RevokeCertificateController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; use App\\Cert; use App\\Params; use File; class RevokeCertificateController extends Controller { /** * Display a listing of the resource. * * @return \\Illuminate\\Http\\Response */ public function index() { // } /** * Show the form for creating a new resource. * * @return \\Illuminate\\Http\\Response */ public function create() { // } /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function store(Request $request) { $cert = Cert::where('id', $request->id)->get()->first(); $config = '/usr/lib/ssl/openssl.cnf'; $certFile = storage_path('archives/tmp/' . $request->id . '.cer'); $password = $request->password; $crlFile = storage_path('archives/ca-g2.crl'); file_put_contents(storage_path('archives/tmp/' . $request->id . '.cer'), $cert->publicKey); $revoke = shell_exec(\"sudo openssl ca -config $config -revoke $certFile -key $password -batch 2>&1\"); $revoked = substr($revoke, -18, 17); //dd($revoke, $revoked); if($revoked == 'Data Base Updated'){ File::delete(storage_path('archives/tmp/' . $request->id . '.cer')); File::delete(storage_path('archives/keypairs/' . $request->id . '.zip')); File::delete(storage_path('archives/monitor/' . $request->id . '.cer')); File::delete(storage_path('archives/p12/' . $request->id . '.p12')); Cert::where('id', $request->id)->update(['status' => 'Revoked']); Cert::where('id', $request->id)->update(['revokedReason' => $request->revokedReason]); shell_exec(\"sudo openssl ca -gencrl -config $config -key $request->password -out $crlFile -batch 2>&1\"); return redirect()->route('admin.certs.index')->with('success','Successfully revoked.'); } else { return redirect()->route('admin.certs.index')->with('error', \" Trace: {$revoke}\"); } } /** * Display the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function show($id) { $params = Params::all(); $cert = Cert::where('id', $id)->get()->first(); $subjectCommonName = $cert->subjectCommonName; $extensionsSubjectAltName = $cert->extensionsSubjectAltName; /** Return error if the certificate can\u00b4t be revoked. */ if($cert->status == 'Revoked') { return redirect()->route('admin.certs.index')->with('error','Certificate is already revoked.'); } elseif ($cert->status == 'Expired') { return redirect()->route('admin.certs.index')->with('error','Certificate is expired.'); } elseif ($cert->publicKey == null) { return redirect()->route('admin.certs.index')->with('error','Certificate not found.'); } else { return view('admin.revoke.show', compact('id', 'params', 'subjectCommonName', 'extensionsSubjectAltName')); } } /** * Show the form for editing the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function edit($id) { // } /** * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request $request * @param int $id * @return \\Illuminate\\Http\\Response */ public function update(Request $request, $id) { // } /** * Remove the specified resource from storage. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function destroy($id) { // } } SigningRequestController \u00b6 app/Http/Controllers/Admin/SigningRequestController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use App\\Http\\Requests\\MassDestroySigningCertificateRequest; use App\\Http\\Requests\\StoreSigningCertificateRequest; use App\\Http\\Requests\\UpdateSigningCertificateRequest; use App\\Cert; use App\\Params; use File; use Carbon\\Carbon; use ZipArchive; class SigningRequestController extends Controller { public function create() { abort_unless(\\Gate::allows('certificate_create'), 403); $params = Params::all(); return view('admin.certs.sign-req.create', compact('params')); } public function store(StoreSigningCertificateRequest $request) { abort_unless(\\Gate::allows('certificate_create'), 403); $subjectCommonName = openssl_csr_get_subject($request->certificateServerRequest, true); $cacert = file_get_contents('/opt/ca/cacert.pem'); $pkeyid = array(file_get_contents('/opt/ca/private/cakey.pem'), $request->password ); $serial = random_int(260001, 270001); // serial for external CSR // Default location for OpenSSL Config file. $config = '/usr/lib/ssl/openssl.cnf'; // Clear SAN DNS entries if previous error. shell_exec(\"sudo /opt/subjectAltNameRemoval.sh 2>&1\"); // Extracting SAN fron CSR. $random_blurp = rand(1000,99999); $tempCSR = \"/tmp/csr-\" . $random_blurp . \".csr.pem\"; $write_csr = file_put_contents($tempCSR, $request->certificateServerRequest); if($write_csr !== FALSE) { $san = trim(shell_exec(\"openssl req -noout -text -in \" . $tempCSR . \" | grep -e 'DNS:' -e 'IP:' -e 'email:'\")); // Not sure if 'email:' works. } unlink($tempCSR); // In case the CSR file doesn\u00b4t include SAN. if($san == \"\"){ $san = 'DNS:' . $subjectCommonName['CN']; } // Include subjectAltName in openssl.cnf. $caConfFile = file_get_contents($config); // Do replacements for SAN in ca.cnf. $caConfFile = str_replace(\"DNS:\",$san, $caConfFile); file_put_contents($config, $caConfFile); unset($caConfFile); // Clears the content of the file. $configArgs = array( 'config' => $config, 'encrypt_key' => false, 'private_key_type' => OPENSSL_KEYTYPE_RSA, 'digest_alg' => $request->signatureTypeSN, 'x509_extensions' => $request->extensionsExtendedKeyUsage ); // Sign certificate and export to string. $cert = openssl_csr_sign($request->certificateServerRequest , $cacert, $pkeyid, $request->validityPeriod, $configArgs, $serial); openssl_x509_export($cert, $publicKey); // Save and zip CSR and Cert in file to ZIP// file_put_contents(storage_path('archives/tmp/cert.csr'), $request->certificateServerRequest); file_put_contents(storage_path('archives/tmp/cert.cer'), $publicKey); // Clean SAN DNS entries. shell_exec(\"sudo /opt/subjectAltNameRemoval.sh 2>&1\"); // Parse Certificate Info. $cert_parse = openssl_x509_parse($publicKey); $request['publicKey'] = $publicKey; $request['name'] = $cert_parse['name']; $request['subject'] = $cert_parse['subject']; $request['subjectCommonName'] = $cert_parse['subject']['CN']; $request['subjectContry'] = $cert_parse['subject']['C']; $request['subjectState'] = $cert_parse['subject']['ST']; $request['subjectLocality'] = $cert_parse['subject']['L']; $request['subjectOrganization'] = $cert_parse['subject']['O']; $request['subjectOrganizationUnit'] = $cert_parse['subject']['OU']; $request['hash'] = $cert_parse['hash']; $request['issuer'] = $cert_parse['issuer']; $request['issuerCN'] = $cert_parse['issuer']['CN']; $request['issuerContry'] = $cert_parse['issuer']['C']; $request['issuerState'] = $cert_parse['issuer']['ST']; //$request['issuerLocality'] = $cert_parse['issuer']['L']; $request['issuerOrganization'] = $cert_parse['issuer']['O']; $request['issuerOrganizationUnit'] = $cert_parse['issuer']['OU']; $request['version'] = $cert_parse['version']; $request['serialNumber'] = $cert_parse['serialNumber']; $request['serialNumberHex'] = $cert_parse['serialNumberHex']; $request['validFrom'] = $cert_parse['validFrom']; $request['validTo'] = $cert_parse['validTo']; $request['validFrom_time_t'] = $cert_parse['validFrom_time_t']; $request['validTo_time_t'] = $cert_parse['validTo_time_t']; $request['signatureTypeSN'] = $cert_parse['signatureTypeSN']; $request['signatureTypeLN'] = $cert_parse['signatureTypeLN']; $request['signatureTypeNID'] = $cert_parse['signatureTypeNID']; //$purposes = $cert_parse['purposes']['1']['2']; dd($purposes); $request['purposes'] = 'Not Implemented'; $request['extensions'] = $cert_parse['extensions']; $request['extensionsBasicConstraints'] = $cert_parse['extensions']['basicConstraints']; //$extensionsExtendedKeyUsage = $cert_parse['extensions']['nsCertType']; $request['extensionsKeyUsage'] = $cert_parse['extensions']['keyUsage']; $request['extensionsExtendedKeyUsage'] = $cert_parse['extensions']['extendedKeyUsage']; $request['extensionsSubjectKeyIdentifier'] = $cert_parse['extensions']['subjectKeyIdentifier']; $request['extensionsAuthorityKeyIdentifier'] = $cert_parse['extensions']['authorityKeyIdentifier']; $request['extensionsSubjectAltName'] = $cert_parse['extensions']['subjectAltName']; $request['extensionsCrlDistributionPoints'] = $cert_parse['extensions']['crlDistributionPoints']; /** Convert dates. */ $validTo_time_t = date(DATE_RFC2822, $request['validTo_time_t']); $expiryDate = Carbon::parse(Carbon::now())->diffInDays($validTo_time_t); $request['expiryDate'] = $expiryDate; $cert = Cert::create($request->all(), $publicKey); $cert->save(); /** Zip the .cer and .key saved in storage_path/tmp and move it to storage_path/archives. */ $zipFile = $cert->id . '.zip'; $zip = new ZipArchive(); $path = storage_path('archives/keypairs/'); $zip->open($path . $zipFile, ZipArchive::CREATE | ZipArchive::CREATE); //$files = new \\RecursiveIteratorIterator(new \\RecursiveDirectoryIterator($path)); $files = File::files(storage_path('archives/tmp/')); foreach ($files as $name => $file) { /** Skipping all subfolders */ if (!$file->isDir()) { $filePath = $file->getRealPath(); /** extracting filename with substr/strlen */ $relativePath = '' . substr($filePath, strlen($path) -5); $zip->addFile($filePath, $relativePath); } } $zip->close(); /** Include certificate to local monitor */ file_put_contents(storage_path('archives/monitor/' . $cert->id . '.cer'), $publicKey); File::delete(storage_path('archives/tmp/' . 'cert.csr')); File::delete(storage_path('archives/tmp/' . 'cert.cer')); return redirect()->route('admin.certs.index'); } public function edit(Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); return view('admin.certs.edit', compact('cert')); } public function update(UpdateSigningCertificateRequest $request, Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); $cert->update($request->all()); return redirect()->route('admin.certs.index'); } public function show(Cert $cert) { abort_unless(\\Gate::allows('certificate_show'), 403); return view('admin.certs.show', compact('cert')); } public function destroy(Cert $cert) { abort_unless(\\Gate::allows('certificate_delete'), 403); $cert->delete(); return back(); } public function massDestroy(MassDestroySigningCertificateRequest $request) { Cert::whereIn('id', request('ids'))->delete(); return response(null, 204); } } UpdateCRLController \u00b6 app/Http/Controllers/Admin/UpdateCRLController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; class UpdateCRLController extends Controller { /** * Display a listing of the resource. * * @return \\Illuminate\\Http\\Response */ public function index() { abort_unless(\\Gate::allows('certificate_access'), 403); return view('admin.update-crl.index'); } /** * Show the form for creating a new resource. * * @return \\Illuminate\\Http\\Response */ public function create() { // } /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function store(Request $request) { $password = $request->password; $crlPath = storage_path('archives/ca-g2.crl'); $updateCRL = shell_exec(\"sudo openssl ca -config /usr/lib/ssl/openssl.cnf -gencrl -out $crlPath -key $request->password -batch 2>&1\"); return redirect()->route('admin.certs.index'); } /** * Display the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function show($id) { // } /** * Show the form for editing the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function edit($id) { // } /** * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request $request * @param int $id * @return \\Illuminate\\Http\\Response */ public function update(Request $request, $id) { // } /** * Remove the specified resource from storage. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function destroy($id) { // } }","title":"Controllers"},{"location":"certificate-authority/code-snippets/controllers/#certificate-authority-controllers","text":"","title":"Certificate Authority Controllers"},{"location":"certificate-authority/code-snippets/controllers/#authenticodecontroller","text":"app/Http/Controllers/Admin/AuthenticodeController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use App\\Http\\Requests\\MassDestroyCertificateRequest; use App\\Http\\Requests\\StoreCertificateRequest; use App\\Http\\Requests\\UpdateCertificateRequest; use App\\Cert; class AuthenticodeController extends Controller { public function index() { abort_unless(\\Gate::allows('certificate_access'), 403); $certsNumber = Cert::all()->count(); $certs = Cert::all(); $certs_status_blank = Cert::where('status', '=', null)->count(); $certs_status_valid = Cert::where('status', '=', 'Valid')->count(); $certs_status_expiring = Cert::where('status', '=', 'Expiring')->count(); $certs_status_expired = Cert::where('status', '=', 'Expired')->count(); $certs_status_revoked = Cert::where('status', '=', 'Revoked')->count(); //dd($certs); return view('admin.certs.index', compact('certs', 'certsNumber', 'certs_status_blank', 'certs_status_valid', 'certs_status_expiring', 'certs_status_expired', 'certs_status_revoked')); } public function create() { abort_unless(\\Gate::allows('certificate_create'), 403); return view('admin.certs.create'); } public function store(StoreCertificateRequest $request) { abort_unless(\\Gate::allows('certificate_create'), 403); $cert = Cert::create($request->all()); return redirect()->route('admin.certs.index'); } public function edit(Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); return view('admin.certs.edit', compact('cert')); } public function update(UpdateCertificateRequest $request, Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); $cert->update($request->all()); return redirect()->route('admin.certs.index'); } public function show(Cert $cert) { abort_unless(\\Gate::allows('certificate_show'), 403); return view('admin.certs.show', compact('cert')); } public function destroy(Cert $cert) { abort_unless(\\Gate::allows('certificate_delete'), 403); $cert->delete(); return back(); } public function massDestroy(MassDestroyCertificateRequest $request) { Cert::whereIn('id', request('ids'))->delete(); return response(null, 204); } }","title":"AuthenticodeController"},{"location":"certificate-authority/code-snippets/controllers/#certificatescontroller","text":"app/Http/Controllers/Admin/CertificatesController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use App\\Http\\Requests\\MassDestroyCertificateKeyPair; use App\\Http\\Requests\\StoreCertificateKeyPair; use App\\Http\\Requests\\UpdateCertificate; use App\\Exceptions\\WrongCaKeyPasswordException; use Spatie\\SslCertificate\\SslCertificate; //use RealRashid\\SweetAlert\\Facades\\Alert; use App\\Cert; use App\\Params; use File; use ZipArchive; use Carbon\\Carbon; class CertificatesController extends Controller { public function index() { abort_unless(\\Gate::allows('certificate_access'), 403); $certsNumber = Cert::all()->count(); $certs = Cert::all(); /** Recalculate the expiry date and update */ foreach ($certs as $cert) { $id = $cert->id; /** calculate days diff between cert and today and update DB. */ if ($cert->validTo_time_t != null){ $certificate = SslCertificate::createFromString($cert->publicKey); //$today = Carbon::today(); $validToDate = $certificate->expirationDate(); $expiryDate = (string)$validToDate->diffInDays(today(), false); $isValid = $certificate->isValid(); $isExpired = $certificate->isExpired(); /** Calculate days to expire. */ $isExpiringInterval = $validToDate->copy()->subDays(60); $isExpiring = today()->isBetween($isExpiringInterval, $validToDate); /** Update diff in day. */ Cert::where('id', $id)->update(['expiryDate' => $expiryDate]); } if (empty($cert->publicKey)){ $status = null; Cert::where('id', $id)->update(['status' => $status]); } elseif ($isExpired === true) { $status = 'Expired'; Cert::where('id', $id)->update(['status' => $status ]); /** Ones cert is expired, it is deleted so that it is not scan with expiry check script. */ FILE::delete(storage_path('archives/keypairs/' . $id . '.zip')); FILE::delete(storage_path('archives/monitor/' . $id . '.cer')); FILE::delete(storage_path('archives/p12/' . $id . '.p12')); } elseif ($isExpiring === true && $cert->status != 'Revoked'){ $status = 'Expiring'; Cert::where('id', $id)->update(['status' => $status]); } elseif ($cert->status === 'Revoked'){ $status = 'Revoked'; Cert::where('id', $id)->update(['status' => $status]); } elseif ($isValid === true){ $status = 'Valid'; Cert::where('id', $id)->update(['status' => $status]); } else { $status = $cert->status; Cert::where('id', $id)->update(['status' => $status]); } } /** Chart */ $certs_status_blank = Cert::where('status', '=', null)->count(); $certs_status_valid = Cert::where('status', '=', 'Valid')->count(); $certs_status_expiring = Cert::where('status', '=', 'Expiring')->count(); $certs_status_expired = Cert::where('status', '=', 'Expired')->count(); $certs_status_revoked = Cert::where('status', '=', 'Revoked')->count(); return view('admin.certs.index', compact('certs', 'certsNumber', 'certs_status_blank', 'certs_status_valid', 'certs_status_expiring', 'certs_status_expired', 'certs_status_revoked' )); } public function create() { abort_unless(\\Gate::allows('certificate_create'), 403); $params = Params::all(); return view('admin.certs.new-cert.create', compact('params')); } public function store(StoreCertificateKeyPair $request) { abort_unless(\\Gate::allows('certificate_create'), 403); /** Separate CN and SANs. */ $commonName = explode(\";\", $request->subjectCommonName); $subjectCommonName = $commonName[0]; $extensionsSubjectAltName = explode(\",\", (\"DNS:\".implode(\",DNS:\", $commonName))); $extensionsSubjectAltName = implode(\",\", $extensionsSubjectAltName); /** Configuration file. */ $config = '/usr/lib/ssl/openssl.cnf'; /** Data needed to populate the certificate signed by this CA. email can\u00b4t be empty so if it is empty \"emailAddress\" is not included. */ if($request->email != ''){ $dn = array( \"countryName\" => 'ES', \"stateOrProvinceName\" => 'Madrid', \"localityName\" => 'Madrid', \"organizationName\" => $request->subjectOrganization, \"organizationalUnitName\" => $organizationUnitName, \"commonName\" => $subjectCommonName, \"emailAddress\" => $request->email ); } else { $dn = array( \"countryName\" => 'ES', \"stateOrProvinceName\" => 'Madrid', \"localityName\" => 'Madrid', \"organizationName\" => $request->subjectOrganization, \"organizationalUnitName\" => $organizationUnitName, \"commonName\" => $subjectCommonName //\"emailAddress\" => null ); } /** Clean DNS entries. */ shell_exec(\"sudo /opt/subjectAltNameRemoval.sh 2>&1\"); /** Clear DNS entries script. */ $configFile = file_get_contents($config); $configFile = str_replace(\"DNS:\", $extensionsSubjectAltName, $configFile); /** Do replacements. */ file_put_contents($config, $configFile); unset($configFile); /** Arguments to be passed to the CSR. */ $configArgs = array( 'config' => $config, 'encrypt_key' => false, 'private_key_type' => OPENSSL_KEYTYPE_RSA, 'subjectAltName' => $request->extensionsSubjectAltName, 'digest_alg' => $request->signatureTypeSN ); /** Generate REQ and his corresponding Private Key. */ $reqgen = openssl_csr_new($dn, $keygen, $configArgs); /** Export Private Key to string and save it to disk. */ openssl_pkey_export($keygen, $privateKey); /** Export CSR to string and save it to disk. */ openssl_csr_export($reqgen, $certificateServerRequest); /** Signing CSR. Location of CA Pub/Priv certificates. */ $cacert = file_get_contents('/opt/ca/cacert.pem'); $pkeyid = array(file_get_contents('/opt/ca/private/cakey.pem'), $request->password ); $configArgs = array( 'config' => $config, 'encrypt_key' => false, 'private_key_bits' => (int)$request->keyLength, 'private_key_type' => OPENSSL_KEYTYPE_RSA, 'digest_alg' => $request->signatureTypeSN, 'x509_extensions' => $request->extensionsExtendedKeyUsage); /** Insert serial number. */ $serialNumber = random_int(160000000001, 170000000001); /** Sign Certificate Server Request. */ $certgen = openssl_csr_sign($certificateServerRequest , $cacert, $pkeyid, $request->validityPeriod, $configArgs, $serialNumber); /** Export signed certificate to string variable and save it to disk. */ openssl_x509_export($certgen, $publicKey); /** Clean SAN DNS entries. */ shell_exec(\"sudo /opt/subjectAltNameRemoval.sh 2>&1\"); /** Parse certificate data. */ $certParser = openssl_x509_parse($publicKey); /** Include certificate parse data in request. */ $request['subjectCommonName'] = $certParser['subject']['CN']; $request['subjectContry'] = $certParser['subject']['C']; $request['subjectState'] = $certParser['subject']['ST']; $request['subjectOrganization'] = $certParser['subject']['O']; $request['subjectOrganizationUnit'] = $certParser['subject']['OU']; $request['hash'] = $certParser['hash']; $request['issuerCN'] = $certParser['issuer']['CN']; $request['issuerOrganization'] = $certParser['issuer']['O']; $request['issuerOrganizationUnit'] = $certParser['issuer']['OU']; $request['version'] = $certParser['version']; $request['serialNumber'] = $serialNumber; //$request['serialNumberHex'] = $serialNumberHex; $request['validFrom'] = $certParser['validFrom']; $request['validTo'] = $certParser['validTo']; $request['validFrom_time_t'] = $certParser['validFrom_time_t']; $request['validTo_time_t'] = $certParser['validTo_time_t']; $request['signatureTypeSN'] = $certParser['signatureTypeSN']; $request['signatureTypeLN'] = $certParser['signatureTypeLN']; $request['signatureTypeNID'] = $certParser['signatureTypeNID']; $request['purposes'] = null; // to be implemented. $request['extensionsBasicConstraints'] = $certParser['extensions']['basicConstraints']; $request['extensionsKeyUsage'] = $certParser['extensions']['keyUsage']; $request['extensionsExtendedKeyUsage'] = $certParser['extensions']['extendedKeyUsage']; $request['extensionsSubjectKeyIdentifier'] = $certParser['extensions']['subjectKeyIdentifier']; $request['extensionsAuthorityKeyIdentifier'] = $certParser['extensions']['authorityKeyIdentifier']; $request['extensionsSubjectAltName'] = $certParser['extensions']['subjectAltName']; $request['extensionsCrlDistributionPoints'] = $certParser['extensions']['crlDistributionPoints']; $request['certificateServerRequest'] = $certificateServerRequest; $request['publicKey'] = $publicKey; $request['privateKey'] = $privateKey; $request['status'] = 'Valid'; $request['p12'] = null; /** Convert dates. */ $validTo_time_t = date(DATE_RFC2822, $certParser['validTo_time_t']); $expiryDate = Carbon::parse(Carbon::now())->diffInDays($validTo_time_t); $request['expiryDate'] = $expiryDate; $cert = Cert::create($request->all()); $cert->save(); $cert = Cert::where('subjectCommonName', $subjectCommonName)->get()->last(); file_put_contents(storage_path('archives/tmp/' . $cert->id . '.key'), $privateKey); file_put_contents(storage_path('archives/tmp/' . $cert->id .'.cer'), $publicKey); file_put_contents(storage_path('archives/tmp/' . $cert->id . '.csr'), $certificateServerRequest); /** If Monitor check enabled, include in /opt/certmon/ json. * Possible solution is to trigger the e-mail or just include the json data in the files. */ /** end include in certmon */ file_put_contents(storage_path('archives/monitor/' . $cert->id . '.cer'), $publicKey); /** Zip the .cer and .key saved in storage_path/tmp and move it to storage_path/archives. then, delete files. */ $zipFile = $cert->id . '.zip'; $zip = new ZipArchive(); $path = storage_path('archives/keypairs/'); $zip->open($path . $zipFile, ZipArchive::CREATE); //$files = new \\RecursiveIteratorIterator(new \\RecursiveDirectoryIterator($path)); $files = File::files(storage_path('archives/tmp/')); foreach ($files as $name => $file) { /** Skipping all subfolders */ if (!$file->isDir()) { $filePath = $file->getRealPath(); /** Extracting filename with substr/strlen */ $relativePath = '' . substr($filePath, strlen($path) -5); $zip->addFile($filePath, $relativePath); } } $zip->close(); File::delete(storage_path('archives/tmp/' . $cert->id . '.csr')); File::delete(storage_path('archives/tmp/' . $cert->id . '.cer')); File::delete(storage_path('archives/tmp/' . $cert->id . '.key')); //Alert::success('Certificate successfully created', 'Certificate keypair has been created', 'Success'); return redirect()->route('admin.certs.index')->with('success', 'Certificate keypair created successfully.'); } public function edit(Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); return view('admin.certs.edit', compact('cert')); } public function update(UpdateCertificate $request, Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); /** Make a Keymatch before updating. */ if ($request->filled(['certificateServerRequest','publicKey', 'privateKey']) && $cert->status != 'Revoked') { /** Check if PublicKey matches PrivateKey. */ $keyMatches = openssl_x509_check_private_key($request->input('publicKey'), $request->input('privateKey')); /** Check if CSR matches PublicKey. */ file_put_contents(storage_path('archives/tmp/') . 'csr.csr', $request->input('certificateServerRequest')); file_put_contents(storage_path('archives/tmp/') . 'cert.cer', $request->input('publicKey')); file_put_contents(storage_path('archives/tmp/') . 'key.key', $request->input('privateKey')); $certSHA2sum = shell_exec(\"openssl x509 -in archives/tmp/cert.cer -pubkey -noout -outform pem | sha256sum 2>&1\"); $csrSHA2sum = shell_exec(\"openssl req -in archives/tmp/csr.csr -pubkey -noout -outform pem | sha256sum 2>&1\"); if($certSHA2sum === $csrSHA2sum && $keyMatches === true){ $cert->update($request->all('certificateServerRequest')); $cert->update($request->all('publicKey')); $cert->update($request->all('privateKey')); $cert->update($request->all('comments')); } else { File::delete(storage_path('archives/tmp/') . 'csr.csr'); File::delete(storage_path('archives/tmp/') . 'cert.cer'); File::delete(storage_path('archives/tmp/') . 'key.key'); return redirect()->route('admin.certs.index')->with('error', 'Certificate and Private key don\u00b4t match'); } /** Parse certificate data. */ $certParser = openssl_x509_parse($request->input('publicKey')); $request['subjectCommonName'] = $certParser['subject']['CN']; $request['subjectContry'] = $certParser['subject']['C']; //$request['subjectState'] = $certParser['subject']['ST']; $request['subjectOrganization'] = $certParser['subject']['O']; //$request['subjectOrganizationUnit'] = $certParser['subject']['OU']; $request['hash'] = $certParser['hash']; $request['issuerCN'] = $certParser['issuer']['CN']; $request['issuerOrganization'] = $certParser['issuer']['O']; //$request['issuerOrganizationUnit'] = $certParser['issuer']['OU']; $request['version'] = $certParser['version']; $request['serialNumber'] = $certParser['serialNumber']; $request['serialNumberHex'] = $certParser['serialNumberHex']; $request['validFrom'] = $certParser['validFrom']; $request['validTo'] = $certParser['validTo']; $request['validFrom_time_t'] = $certParser['validFrom_time_t']; $request['validTo_time_t'] = $certParser['validTo_time_t']; $request['signatureTypeSN'] = $certParser['signatureTypeSN']; $request['signatureTypeLN'] = $certParser['signatureTypeLN']; $request['signatureTypeNID'] = $certParser['signatureTypeNID']; $request['purposes'] = null; $request['extensionsBasicConstraints'] = $certParser['extensions']['basicConstraints']; $request['extensionsKeyUsage'] = $certParser['extensions']['keyUsage']; $request['extensionsExtendedKeyUsage'] = $certParser['extensions']['extendedKeyUsage']; $request['extensionsSubjectKeyIdentifier'] = $certParser['extensions']['subjectKeyIdentifier']; $request['extensionsAuthorityKeyIdentifier'] = $certParser['extensions']['authorityKeyIdentifier']; $request['extensionsSubjectAltName'] = $certParser['extensions']['subjectAltName']; $request['extensionsCrlDistributionPoints'] = $certParser['extensions']['crlDistributionPoints']; $request['certificateServerRequest'] = $request->input('certificateServerRequest'); $request['publicKey'] = $request->input('publicKey'); $request['privateKey'] = $request->input('privateKey'); $request['p12'] = null; /** Convert dates. */ $validTo_time_t = date(DATE_RFC2822, $certParser['validTo_time_t']); $expiryDate = Carbon::parse(Carbon::now())->diffInDays($validTo_time_t, false); /** in days */ $request['expiryDate'] = $expiryDate; /** Calculate status: Valid,Expiring, Expired. */ if($expiryDate > 0) { $request['status'] = 'Valid'; } elseif($expiryDate >= 90) { $request['status'] = 'Expiring'; } elseif($expiryDate < 0) { $request['status'] = 'Expired'; } $cert->update($request->all( 'subjectCommonName', 'subjectContry', //'subjectState', 'subjectOrganization', //'subjectOrganizationUnit', 'hash', 'issuerCN', 'issuerOrganization', //'issuerOrganizationUnit', 'version', 'serialNumber', 'serialNumberHex', 'validFrom', 'validTo', 'validFrom_time_t', 'validTo_time_t', 'expiryDate', 'signatureTypeSN', 'signatureTypeLN', 'signatureTypeNID', 'purposes', 'extensionsBasicConstraints', 'extensionsKeyUsage', 'extensionsExtendedKeyUsage', 'extensionsSubjectKeyIdentifier', 'extensionsSubjectAltName', 'extensionsSubjectAltName', 'extensionsCrlDistributionPoints', 'certificateServerRequest', 'publicKey', 'privateKey', 'status', 'p12', )); /** Include certificate to local monitor */ file_put_contents(storage_path('archives/monitor/' . $cert->id . '.cer'), $request->publicKey); /** Zip the .cer and .key saved in storage_path/tmp and move it to storage_path/archives. */ $zipFile = $cert->id . '.zip'; $zip = new ZipArchive(); $path = storage_path('archives/keypairs/'); $zip->open($path . $zipFile, ZipArchive::CREATE | ZipArchive::OVERWRITE); //$files = new \\RecursiveIteratorIterator(new \\RecursiveDirectoryIterator($path)); $files = File::files(storage_path('archives/tmp/')); foreach ($files as $name => $file) { /** Skipping all subfolders */ if (!$file->isDir()) { $filePath = $file->getRealPath(); /** extracting filename with substr/strlen */ $relativePath = '' . substr($filePath, strlen($path) -5); $zip->addFile($filePath, $relativePath); } } $zip->close(); /** Include certificate to local monitor */ file_put_contents(storage_path('archives/monitor/' . $cert->id . '.cer'), $request->publicKey); File::delete(storage_path('archives/tmp/') . 'csr.csr'); File::delete(storage_path('archives/tmp/') . 'cert.cer'); File::delete(storage_path('archives/tmp/') . 'key.key'); return redirect()->route('admin.certs.index')->with('success','Updated successfully.'); } elseif ($cert->status === 'Revoked'){ return redirect()->route('admin.certs.index')->with('error','Certificate is Revoked and can\u00b4t be updated.'); } else { //Alert::error('Error Updating', 'Data don\u00b4t match or has not been provided.', 'error')->persistent('close'); return redirect()->route('admin.certs.index')->with('error','Error updating. Check if public and private key matches.'); } } public function show(Cert $cert) { abort_unless(\\Gate::allows('certificate_show'), 403); /** Convert dates validFrom and validTo to show them properly in view. */ $certs = Cert::all(); $validFrom_time_t = date(DATE_RFC2822, $cert->validFrom_time_t); $validTo_time_t = date(DATE_RFC2822, $cert->validTo_time_t); $created_at = $cert->created_at; return view('admin.certs.show', compact( 'cert', 'validFrom_time_t', 'validTo_time_t', 'created_at' )); } public function destroy(Cert $cert) { abort_unless(\\Gate::allows('certificate_delete'), 403); $cert->delete(); /** Delete file from storage. This file is used by the local monitoring script */ //Alert::success('Deleted Successfully', 'All data related to this certificate has been deleted.', 'Success'); File::delete(storage_path('archives/monitor/' . $cert->id .'.cer')); File::delete(storage_path('archives/keypairs/' . $cert->id .'.zip')); return back(); } public function massDestroy(MassDestroyCertificateKeyPair $request) { Cert::whereIn('id', request('ids'))->delete(); return response(null, 204); } }","title":"CertificatesController"},{"location":"certificate-authority/code-snippets/controllers/#convertercontroller","text":"app/Http/Controllers/Admin/ConverterController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; use App\\Cert; class ConverterController extends Controller { /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function index() { // } /** * Show the form for creating a new resource. * * @return \\Illuminate\\Http\\Request * @return \\Illuminate\\Http\\Response */ public function create($id) { // } /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function store(Request $request) { $cert = Cert::where('id', $request->id)->get()->first(); $p12Args = array( 'friendly_name' => $cert->subjectCommonName, 'extracerts' => storage_path('archives/','cert.ca.cer') ); /** Export it to string format in order to insert it in database and to file to back it up in archives/p12/ */ openssl_pkcs12_export($cert->publicKey, $p12String, $cert->privateKey, $request->password, $p12Args); openssl_pkcs12_export_to_file($cert->publicKey, storage_path('archives/p12/' . $request->id . '.p12'), $cert->privateKey, $request->password, $p12Args); /** Update database field 'p12' */ Cert::where('id', $request->id)->update(['p12' => $p12String]); $headers = array('Content_Type: application/x-download',); return response()->download(storage_path('archives/p12/' . $request->id . '.p12'), $request->id . '.p12', $headers); } /** * Display the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function Show($id) { $cert = Cert::where('id', $id)->get()->first(); $subjectCommonName = $cert->subjectCommonName; if ($cert->publicKey == null OR $cert->privateKey == null){ return redirect()->route('admin.certs.index')->with('error','Keys not found. Check if Public and Private keys exist and match.'); } else { return view('admin.converter.show', compact('id', 'subjectCommonName')); } } /** * Show the form for editing the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function edit($id) { dd('Edit'); } /** * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request $request * @param int $id * @return \\Illuminate\\Http\\Response */ public function update(Request $request, $id) { dd('Update'); } /** * Remove the specified resource from storage. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function destroy($id) { dd('Destroy'); } }","title":"ConverterController"},{"location":"certificate-authority/code-snippets/controllers/#downloadarchivecontroller","text":"app/Http/Controllers/Admin/DownloadArchiveController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Support\\Facades\\Response; class DownloadArchiveController extends Controller { function downloadArchive($id){ $headers = array('Content_Type: application/x-download'); return Response::download(storage_path('archives/keypairs/' . $id . '.zip'), $id . '.zip', $headers); } function downloadCA(){ $headers = array('Content_Type: application/x-download'); return Response::download(storage_path('archives/cert.ca.cer'), 'cert.ca.cer', $headers); } function downloadCRL(){ $headers = array('Content_Type: application/x-download'); return Response::download(storage_path('archives/ca-g2.crl'), 'ca-g2.crl', $headers); } }","title":"DownloadArchiveController"},{"location":"certificate-authority/code-snippets/controllers/#importcontroller","text":"app/Http/Controllers/Admin/ImportController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Support\\Facades\\Response; use Illuminate\\Http\\Request; class ImportController extends Controller { /** * Display a listing of the resource. * * @return \\Illuminate\\Http\\Response */ public function index() { // Code } /** * Show the form for creating a new resource. * * @return \\Illuminate\\Http\\Response */ public function create(Request $request) { return view('admin.import.create'); } /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function store(Request $request) { // } /** * Display the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function show($id) { // } /** * Show the form for editing the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function edit($id) { // } /** * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request $request * @param int $id * @return \\Illuminate\\Http\\Response */ public function update(Request $request, $id) { // } /** * Remove the specified resource from storage. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function destroy($id) { // } }","title":"ImportController"},{"location":"certificate-authority/code-snippets/controllers/#jarsignercontroller","text":"app/Http/Controllers/Admin/JarSignerController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use App\\Http\\Requests\\MassDestroyCertificateRequest; use App\\Http\\Requests\\StoreCertificateRequest; use App\\Http\\Requests\\UpdateCertificateRequest; use App\\Cert; class JarSignerController extends Controller { public function index() { abort_unless(\\Gate::allows('certificate_access'), 403); $certsNumber = Cert::all()->count(); $certs = Cert::all(); // Chart - Certificates status. $certs_status_blank = Cert::where('status', '=', null)->count(); $certs_status_valid = Cert::where('status', '=', 'Valid')->count(); $certs_status_expiring = Cert::where('status', '=', 'Expiring')->count(); $certs_status_expired = Cert::where('status', '=', 'Expired')->count(); $certs_status_revoked = Cert::where('status', '=', 'Revoked')->count(); //dd($certs); return view('admin.certs.index', compact('certs', 'certsNumber', 'certs_status_blank', 'certs_status_valid', 'certs_status_expiring', 'certs_status_expired', 'certs_status_revoked')); } public function create() { abort_unless(\\Gate::allows('certificate_create'), 403); return view('admin.certs.create'); } public function store(StoreCertificateRequest $request) { abort_unless(\\Gate::allows('certificate_create'), 403); $cert = Cert::create($request->all()); return redirect()->route('admin.certs.index'); } public function edit(Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); return view('admin.certs.edit', compact('cert')); } public function update(UpdateCertificateRequest $request, Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); $cert->update($request->all()); return redirect()->route('admin.certs.index'); } public function show(Cert $cert) { abort_unless(\\Gate::allows('certificate_show'), 403); return view('admin.certs.show', compact('cert')); } public function destroy(Cert $cert) { abort_unless(\\Gate::allows('certificate_delete'), 403); $cert->delete(); return back(); } public function massDestroy(MassDestroyCertificateRequest $request) { Cert::whereIn('id', request('ids'))->delete(); return response(null, 204); } }","title":"JarSignerController"},{"location":"certificate-authority/code-snippets/controllers/#keymatchercertificatecontroller","text":"app/Http/Controllers/Admin/ConverterController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; use App\\Cert; class ConverterController extends Controller { /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function index() { // } /** * Show the form for creating a new resource. * * @return \\Illuminate\\Http\\Request * @return \\Illuminate\\Http\\Response */ public function create($id) { // } /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function store(Request $request) { $cert = Cert::where('id', $request->id)->get()->first(); $p12Args = array( 'friendly_name' => $cert->subjectCommonName, 'extracerts' => storage_path('archives/','cert.ca.cer') ); /** Export it to string format in order to insert it in database and to file to back it up in archives/p12/ */ openssl_pkcs12_export($cert->publicKey, $p12String, $cert->privateKey, $request->password, $p12Args); openssl_pkcs12_export_to_file($cert->publicKey, storage_path('archives/p12/' . $request->id . '.p12'), $cert->privateKey, $request->password, $p12Args); /** Update database field 'p12' */ Cert::where('id', $request->id)->update(['p12' => $p12String]); $headers = array('Content_Type: application/x-download',); return response()->download(storage_path('archives/p12/' . $request->id . '.p12'), $request->id . '.p12', $headers); } /** * Display the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function Show($id) { $cert = Cert::where('id', $id)->get()->first(); $subjectCommonName = $cert->subjectCommonName; if ($cert->publicKey == null OR $cert->privateKey == null){ return redirect()->route('admin.certs.index')->with('error','Keys not found. Check if Public and Private keys exist and match.'); } else { return view('admin.converter.show', compact('id', 'subjectCommonName')); } } /** * Show the form for editing the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function edit($id) { dd('Edit'); } /** * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request $request * @param int $id * @return \\Illuminate\\Http\\Response */ public function update(Request $request, $id) { dd('Update'); } /** * Remove the specified resource from storage. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function destroy($id) { dd('Destroy'); } }","title":"KeyMatcherCertificateController"},{"location":"certificate-authority/code-snippets/controllers/#newsigningrequestcontroller","text":"app/Http/Controllers/Admin/KeyMatcherCertificateController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; use App\\Params; use App\\Cert; use File; class KeyMatcherCertificateController extends Controller { /** * Display a listing of the resource. * * @return \\Illuminate\\Http\\Response */ public function index() { // } /** * Show the form for creating a new resource. * * @return \\Illuminate\\Http\\Response */ public function create() { // } /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function store(Request $request) { // } /** * Display the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function show($id) { $params = Params::all(); $cert = Cert::where('id', $id)->get()->first(); $subjectCommonName = $cert->subjectCommonName; $extensionsSubjectAltName = $cert->extensionsSubjectAltName; /** Check if csr/cert/key are in DB. */ if($cert->certificateServerRequest != null){ $csr_status = 'Found'; } else { $csr_status = 'Not found'; } if($cert->publicKey != null){ $cert_status = 'Found'; } else { $cert_status = 'Not found'; } if($cert->privateKey != null){ $key_status = 'Found'; } else { $key_status = 'Not found'; } /** Checks if a private key matches certificate. */ $keyMatchesCert = openssl_x509_check_private_key($cert->publicKey, $cert->privateKey); if($keyMatchesCert === true){ $keyMatchesCert = 'YES'; } else { $keyMatchesCert = 'NO'; } file_put_contents(storage_path('archives/tmp/') . 'temp.csr', $cert->certificateServerRequest); file_put_contents(storage_path('archives/tmp/') . 'temp.cer', $cert->publicKey); $certSHA2sum = shell_exec(\"openssl x509 -in archives/tmp/temp.cer -pubkey -noout -outform pem | sha256sum 2>&1\"); $csrSHA2sum = shell_exec(\"openssl req -in archives/tmp/temp.csr -pubkey -noout -outform pem | sha256sum 2>&1\"); if($certSHA2sum === $csrSHA2sum){ $certMatchesCSR = 'YES'; } else { $certMatchesCSR = 'NO'; } File::delete(storage_path('archives/tmp/') . 'temp.csr'); File::delete(storage_path('archives/tmp/') . 'temp.cer'); return view('admin.keymatcher.show', compact( 'id', 'params', 'subjectCommonName', 'extensionsSubjectAltName', 'csr_status', 'cert_status', 'key_status', 'keyMatchesCert', 'certMatchesCSR', 'certSHA2sum', 'csrSHA2sum' )); } /** * Show the form for editing the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function edit($id) { // } /** * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request $request * @param int $id * @return \\Illuminate\\Http\\Response */ public function update(Request $request, $id) { // } /** * Remove the specified resource from storage. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function destroy($id) { // } }","title":"NewSigningRequestController"},{"location":"certificate-authority/code-snippets/controllers/#renewcertificatecontroller","text":"app/Http/Controllers/Admin/RenewCertificateController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; use App\\Cert; use App\\Params; use File; use ZipArchive; class RenewCertificateController extends Controller { /** * Display a listing of the resource. * * @return \\Illuminate\\Http\\Response */ public function index() { // } /** * Show the form for creating a new resource. * * @return \\Illuminate\\Http\\Response */ public function create() { // } /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function store(Request $request) { $cert = Cert::where('id', $request->id)->get()->first(); $config = '/usr/lib/ssl/openssl.cnf'; /** Clean DNS: entries in ca.cnf */ shell_exec(\"sudo /opt/subjectAltNameRemoval.sh 2>&1\"); /** Open ca.cnf, insert extensionsSubjectAltName and save ca.cnf */ $insertSAN = file_get_contents($config); $insertSAN = str_replace(\"DNS:\", $cert->extensionsSubjectAltName, $insertSAN); file_put_contents($config, $insertSAN); unset($insertSAN); /** Arguments pass to the CSR */ $configArgs = array( 'config' => $config, 'encrypt_key' => false, 'private_key_type' => OPENSSL_KEYTYPE_RSA, 'subjectAltName' => $cert->extensionsSubjectAltName, // Not needed since it is hardcoded (above) in config file. 'digest_alg' => $cert->signatureTypeSN, 'x509_extensions' => $cert->extensionsExtendedKeyUsage ); $serialNumber = random_int(160000000001, 170000000001); // serial for external CSR in Decimal format. $serialNumberHex = dechex($serialNumber); // serial for external CSR in Hexadecimal format. $cacert = file_get_contents('/opt/ca/cacert.pem'); $pkeyid = array(file_get_contents('/opt/ca/private/cakey.pem'), $request->password ); /** Sign csr from DB */ $csr_sign = openssl_csr_sign($cert->certificateServerRequest , $cacert, $pkeyid, $request->validityPeriod, $configArgs, $serialNumber); /** Export signed certificate to string variable. */ openssl_x509_export($csr_sign, $publicKey); /** Replace publickey for monitoring */ File::delete(storage_path('archives/monitor/' . $cert->id . '.cer')); file_put_contents(storage_path('archives/monitor/' . $cert->id . '.cer'), $publicKey); /** Update archive/keypairs archive with new certificate */ $zipFile = $cert->id . '.zip'; $zip = new ZipArchive(); $path = storage_path('archives/keypairs/'); $zip->open($path . $zipFile, ZipArchive::CREATE); //$files = new \\RecursiveIteratorIterator(new \\RecursiveDirectoryIterator($path)); $zip->addFile(storage_path('archives/monitor/' . $cert->id . '.cer'), $cert->id . '.cer'); $zip->close(); shell_exec(\"sudo /opt/subjectAltNameRemoval.sh 2>&1\"); /** Certificate parser */ $certParser = openssl_x509_parse($publicKey); /** DB updates */ Cert::where('id', $cert->id)->update(['expiryDate' => $request->validityPeriod]); Cert::where('id', $cert->id)->update(['serialNumber' => $serialNumber]); Cert::where('id', $cert->id)->update(['serialNumberHex' => $serialNumberHex]); Cert::where('id', $cert->id)->update(['publicKey' => $publicKey]); Cert::where('id', $cert->id)->update(['p12' => null]); Cert::where('id', $cert->id)->update(['validFrom' => $certParser['validFrom']]); Cert::where('id', $cert->id)->update(['validTo' => $certParser['validTo']]); Cert::where('id', $cert->id)->update(['validFrom_time_t' => $certParser['validFrom_time_t']]); Cert::where('id', $cert->id)->update(['validTo_time_t' => $certParser['validTo_time_t']]); Cert::where('id', $cert->id)->update(['hash' => $certParser['hash']]); Cert::where('id', $cert->id)->update(['extensionsSubjectKeyIdentifier' => $certParser['extensions']['subjectKeyIdentifier']]); Cert::where('id', $cert->id)->update(['extensionsAuthorityKeyIdentifier' => $certParser['extensions']['authorityKeyIdentifier']]); Cert::where('id', $cert->id)->update(['status' => 'Valid']); return redirect()->route('admin.certs.index')->with('success', \"Certificate successfully renewed.\"); } /** * Display the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function show($id) { $params = Params::all(); $cert = Cert::where('id', $id)->get()->first(); $subjectCommonName = $cert->subjectCommonName; $extensionsSubjectAltName = $cert->extensionsSubjectAltName; if ($cert->certificateServerRequest == null OR $cert->privateKey == null OR $cert->status == 'Revoked'){ return redirect()->route('admin.certs.index')->with('error',\"Keys not found. Check if Request (CSR) and Private keys exist and match OR if certificate is Revoked.\"); } elseif ($cert->issuerCN !== 'LIQUABit Root CA') { // Extract issuer from cert ca.cert.cert nad meke it dynamic. return redirect()->route('admin.certs.index')->with('error', \"Issuer mismatch. It seems that this certificate has been issued by: {$cert->issuerCN}\"); } else { return view('admin.renew.show', compact('id', 'params', 'subjectCommonName', 'extensionsSubjectAltName')); } } /** * Show the form for editing the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function edit($id) { // } /** * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request $request * @param int $id * @return \\Illuminate\\Http\\Response */ public function update(Request $request, $id) { // } /** * Remove the specified resource from storage. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function destroy($id) { // } }","title":"RenewCertificateController"},{"location":"certificate-authority/code-snippets/controllers/#revokecertificatecontroller","text":"app/Http/Controllers/Admin/RevokeCertificateController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; use App\\Cert; use App\\Params; use File; class RevokeCertificateController extends Controller { /** * Display a listing of the resource. * * @return \\Illuminate\\Http\\Response */ public function index() { // } /** * Show the form for creating a new resource. * * @return \\Illuminate\\Http\\Response */ public function create() { // } /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function store(Request $request) { $cert = Cert::where('id', $request->id)->get()->first(); $config = '/usr/lib/ssl/openssl.cnf'; $certFile = storage_path('archives/tmp/' . $request->id . '.cer'); $password = $request->password; $crlFile = storage_path('archives/ca-g2.crl'); file_put_contents(storage_path('archives/tmp/' . $request->id . '.cer'), $cert->publicKey); $revoke = shell_exec(\"sudo openssl ca -config $config -revoke $certFile -key $password -batch 2>&1\"); $revoked = substr($revoke, -18, 17); //dd($revoke, $revoked); if($revoked == 'Data Base Updated'){ File::delete(storage_path('archives/tmp/' . $request->id . '.cer')); File::delete(storage_path('archives/keypairs/' . $request->id . '.zip')); File::delete(storage_path('archives/monitor/' . $request->id . '.cer')); File::delete(storage_path('archives/p12/' . $request->id . '.p12')); Cert::where('id', $request->id)->update(['status' => 'Revoked']); Cert::where('id', $request->id)->update(['revokedReason' => $request->revokedReason]); shell_exec(\"sudo openssl ca -gencrl -config $config -key $request->password -out $crlFile -batch 2>&1\"); return redirect()->route('admin.certs.index')->with('success','Successfully revoked.'); } else { return redirect()->route('admin.certs.index')->with('error', \" Trace: {$revoke}\"); } } /** * Display the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function show($id) { $params = Params::all(); $cert = Cert::where('id', $id)->get()->first(); $subjectCommonName = $cert->subjectCommonName; $extensionsSubjectAltName = $cert->extensionsSubjectAltName; /** Return error if the certificate can\u00b4t be revoked. */ if($cert->status == 'Revoked') { return redirect()->route('admin.certs.index')->with('error','Certificate is already revoked.'); } elseif ($cert->status == 'Expired') { return redirect()->route('admin.certs.index')->with('error','Certificate is expired.'); } elseif ($cert->publicKey == null) { return redirect()->route('admin.certs.index')->with('error','Certificate not found.'); } else { return view('admin.revoke.show', compact('id', 'params', 'subjectCommonName', 'extensionsSubjectAltName')); } } /** * Show the form for editing the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function edit($id) { // } /** * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request $request * @param int $id * @return \\Illuminate\\Http\\Response */ public function update(Request $request, $id) { // } /** * Remove the specified resource from storage. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function destroy($id) { // } }","title":"RevokeCertificateController"},{"location":"certificate-authority/code-snippets/controllers/#signingrequestcontroller","text":"app/Http/Controllers/Admin/SigningRequestController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use App\\Http\\Requests\\MassDestroySigningCertificateRequest; use App\\Http\\Requests\\StoreSigningCertificateRequest; use App\\Http\\Requests\\UpdateSigningCertificateRequest; use App\\Cert; use App\\Params; use File; use Carbon\\Carbon; use ZipArchive; class SigningRequestController extends Controller { public function create() { abort_unless(\\Gate::allows('certificate_create'), 403); $params = Params::all(); return view('admin.certs.sign-req.create', compact('params')); } public function store(StoreSigningCertificateRequest $request) { abort_unless(\\Gate::allows('certificate_create'), 403); $subjectCommonName = openssl_csr_get_subject($request->certificateServerRequest, true); $cacert = file_get_contents('/opt/ca/cacert.pem'); $pkeyid = array(file_get_contents('/opt/ca/private/cakey.pem'), $request->password ); $serial = random_int(260001, 270001); // serial for external CSR // Default location for OpenSSL Config file. $config = '/usr/lib/ssl/openssl.cnf'; // Clear SAN DNS entries if previous error. shell_exec(\"sudo /opt/subjectAltNameRemoval.sh 2>&1\"); // Extracting SAN fron CSR. $random_blurp = rand(1000,99999); $tempCSR = \"/tmp/csr-\" . $random_blurp . \".csr.pem\"; $write_csr = file_put_contents($tempCSR, $request->certificateServerRequest); if($write_csr !== FALSE) { $san = trim(shell_exec(\"openssl req -noout -text -in \" . $tempCSR . \" | grep -e 'DNS:' -e 'IP:' -e 'email:'\")); // Not sure if 'email:' works. } unlink($tempCSR); // In case the CSR file doesn\u00b4t include SAN. if($san == \"\"){ $san = 'DNS:' . $subjectCommonName['CN']; } // Include subjectAltName in openssl.cnf. $caConfFile = file_get_contents($config); // Do replacements for SAN in ca.cnf. $caConfFile = str_replace(\"DNS:\",$san, $caConfFile); file_put_contents($config, $caConfFile); unset($caConfFile); // Clears the content of the file. $configArgs = array( 'config' => $config, 'encrypt_key' => false, 'private_key_type' => OPENSSL_KEYTYPE_RSA, 'digest_alg' => $request->signatureTypeSN, 'x509_extensions' => $request->extensionsExtendedKeyUsage ); // Sign certificate and export to string. $cert = openssl_csr_sign($request->certificateServerRequest , $cacert, $pkeyid, $request->validityPeriod, $configArgs, $serial); openssl_x509_export($cert, $publicKey); // Save and zip CSR and Cert in file to ZIP// file_put_contents(storage_path('archives/tmp/cert.csr'), $request->certificateServerRequest); file_put_contents(storage_path('archives/tmp/cert.cer'), $publicKey); // Clean SAN DNS entries. shell_exec(\"sudo /opt/subjectAltNameRemoval.sh 2>&1\"); // Parse Certificate Info. $cert_parse = openssl_x509_parse($publicKey); $request['publicKey'] = $publicKey; $request['name'] = $cert_parse['name']; $request['subject'] = $cert_parse['subject']; $request['subjectCommonName'] = $cert_parse['subject']['CN']; $request['subjectContry'] = $cert_parse['subject']['C']; $request['subjectState'] = $cert_parse['subject']['ST']; $request['subjectLocality'] = $cert_parse['subject']['L']; $request['subjectOrganization'] = $cert_parse['subject']['O']; $request['subjectOrganizationUnit'] = $cert_parse['subject']['OU']; $request['hash'] = $cert_parse['hash']; $request['issuer'] = $cert_parse['issuer']; $request['issuerCN'] = $cert_parse['issuer']['CN']; $request['issuerContry'] = $cert_parse['issuer']['C']; $request['issuerState'] = $cert_parse['issuer']['ST']; //$request['issuerLocality'] = $cert_parse['issuer']['L']; $request['issuerOrganization'] = $cert_parse['issuer']['O']; $request['issuerOrganizationUnit'] = $cert_parse['issuer']['OU']; $request['version'] = $cert_parse['version']; $request['serialNumber'] = $cert_parse['serialNumber']; $request['serialNumberHex'] = $cert_parse['serialNumberHex']; $request['validFrom'] = $cert_parse['validFrom']; $request['validTo'] = $cert_parse['validTo']; $request['validFrom_time_t'] = $cert_parse['validFrom_time_t']; $request['validTo_time_t'] = $cert_parse['validTo_time_t']; $request['signatureTypeSN'] = $cert_parse['signatureTypeSN']; $request['signatureTypeLN'] = $cert_parse['signatureTypeLN']; $request['signatureTypeNID'] = $cert_parse['signatureTypeNID']; //$purposes = $cert_parse['purposes']['1']['2']; dd($purposes); $request['purposes'] = 'Not Implemented'; $request['extensions'] = $cert_parse['extensions']; $request['extensionsBasicConstraints'] = $cert_parse['extensions']['basicConstraints']; //$extensionsExtendedKeyUsage = $cert_parse['extensions']['nsCertType']; $request['extensionsKeyUsage'] = $cert_parse['extensions']['keyUsage']; $request['extensionsExtendedKeyUsage'] = $cert_parse['extensions']['extendedKeyUsage']; $request['extensionsSubjectKeyIdentifier'] = $cert_parse['extensions']['subjectKeyIdentifier']; $request['extensionsAuthorityKeyIdentifier'] = $cert_parse['extensions']['authorityKeyIdentifier']; $request['extensionsSubjectAltName'] = $cert_parse['extensions']['subjectAltName']; $request['extensionsCrlDistributionPoints'] = $cert_parse['extensions']['crlDistributionPoints']; /** Convert dates. */ $validTo_time_t = date(DATE_RFC2822, $request['validTo_time_t']); $expiryDate = Carbon::parse(Carbon::now())->diffInDays($validTo_time_t); $request['expiryDate'] = $expiryDate; $cert = Cert::create($request->all(), $publicKey); $cert->save(); /** Zip the .cer and .key saved in storage_path/tmp and move it to storage_path/archives. */ $zipFile = $cert->id . '.zip'; $zip = new ZipArchive(); $path = storage_path('archives/keypairs/'); $zip->open($path . $zipFile, ZipArchive::CREATE | ZipArchive::CREATE); //$files = new \\RecursiveIteratorIterator(new \\RecursiveDirectoryIterator($path)); $files = File::files(storage_path('archives/tmp/')); foreach ($files as $name => $file) { /** Skipping all subfolders */ if (!$file->isDir()) { $filePath = $file->getRealPath(); /** extracting filename with substr/strlen */ $relativePath = '' . substr($filePath, strlen($path) -5); $zip->addFile($filePath, $relativePath); } } $zip->close(); /** Include certificate to local monitor */ file_put_contents(storage_path('archives/monitor/' . $cert->id . '.cer'), $publicKey); File::delete(storage_path('archives/tmp/' . 'cert.csr')); File::delete(storage_path('archives/tmp/' . 'cert.cer')); return redirect()->route('admin.certs.index'); } public function edit(Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); return view('admin.certs.edit', compact('cert')); } public function update(UpdateSigningCertificateRequest $request, Cert $cert) { abort_unless(\\Gate::allows('certificate_edit'), 403); $cert->update($request->all()); return redirect()->route('admin.certs.index'); } public function show(Cert $cert) { abort_unless(\\Gate::allows('certificate_show'), 403); return view('admin.certs.show', compact('cert')); } public function destroy(Cert $cert) { abort_unless(\\Gate::allows('certificate_delete'), 403); $cert->delete(); return back(); } public function massDestroy(MassDestroySigningCertificateRequest $request) { Cert::whereIn('id', request('ids'))->delete(); return response(null, 204); } }","title":"SigningRequestController"},{"location":"certificate-authority/code-snippets/controllers/#updatecrlcontroller","text":"app/Http/Controllers/Admin/UpdateCRLController.php <?php namespace App\\Http\\Controllers\\Admin; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; class UpdateCRLController extends Controller { /** * Display a listing of the resource. * * @return \\Illuminate\\Http\\Response */ public function index() { abort_unless(\\Gate::allows('certificate_access'), 403); return view('admin.update-crl.index'); } /** * Show the form for creating a new resource. * * @return \\Illuminate\\Http\\Response */ public function create() { // } /** * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function store(Request $request) { $password = $request->password; $crlPath = storage_path('archives/ca-g2.crl'); $updateCRL = shell_exec(\"sudo openssl ca -config /usr/lib/ssl/openssl.cnf -gencrl -out $crlPath -key $request->password -batch 2>&1\"); return redirect()->route('admin.certs.index'); } /** * Display the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function show($id) { // } /** * Show the form for editing the specified resource. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function edit($id) { // } /** * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request $request * @param int $id * @return \\Illuminate\\Http\\Response */ public function update(Request $request, $id) { // } /** * Remove the specified resource from storage. * * @param int $id * @return \\Illuminate\\Http\\Response */ public function destroy($id) { // } }","title":"UpdateCRLController"},{"location":"certificate-authority/code-snippets/models/","text":"Certificate Authority Models \u00b6 Cert \u00b6 Params \u00b6","title":"Models"},{"location":"certificate-authority/code-snippets/models/#certificate-authority-models","text":"","title":"Certificate Authority Models"},{"location":"certificate-authority/code-snippets/models/#cert","text":"","title":"Cert"},{"location":"certificate-authority/code-snippets/models/#params","text":"","title":"Params"},{"location":"certificate-authority/code-snippets/views/","text":"Certificate Authority Views \u00b6 Dashboard \u00b6","title":"Views"},{"location":"certificate-authority/code-snippets/views/#certificate-authority-views","text":"","title":"Certificate Authority Views"},{"location":"certificate-authority/code-snippets/views/#dashboard","text":"","title":"Dashboard"},{"location":"certificate-monitor/","text":"","title":"Index"},{"location":"changelog/","text":"Changelog \u00b6 Certificate Authority Management Console \u00b6 2.0.0 _ December, 2021 \u00b6 Certificate status in dashboard valid expiring expired revoked are now calculated correctly. When codesigning .jar,.jnlp and .exe,.dll,.msi , archives are downloaded and not saved on storage. Import own CA certificate and Key. Certificate Authority API \u00b6 0.0.1 _ January, 2022 \u00b6","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#certificate-authority-management-console","text":"","title":"Certificate Authority Management Console"},{"location":"changelog/#2.0.0","text":"Certificate status in dashboard valid expiring expired revoked are now calculated correctly. When codesigning .jar,.jnlp and .exe,.dll,.msi , archives are downloaded and not saved on storage. Import own CA certificate and Key.","title":"2.0.0 _ December, 2021"},{"location":"changelog/#certificate-authority-api","text":"","title":"Certificate Authority API"},{"location":"changelog/#0.0.1","text":"","title":"0.0.1 _ January, 2022"},{"location":"references/","text":"References \u00b6","title":"References"},{"location":"references/#references","text":"","title":"References"},{"location":"references/bluecoat/","text":"BlueCoat SG \u00b6","title":"BlueCoat"},{"location":"references/bluecoat/#bluecoat-sg","text":"","title":"BlueCoat SG"},{"location":"references/checkpoint/","text":"CheckPoint \u00b6","title":"CheckPoint"},{"location":"references/checkpoint/#checkpoint","text":"","title":"CheckPoint"},{"location":"references/f5-networks/","text":"F5 Networks \u00b6","title":"F5 Networks"},{"location":"references/f5-networks/#f5-networks","text":"","title":"F5 Networks"},{"location":"references/fortigate/","text":"FortiGate \u00b6","title":"FortiGate"},{"location":"references/fortigate/#fortigate","text":"","title":"FortiGate"},{"location":"scripts/","text":"Scrips \u00b6","title":"Scrips"},{"location":"scripts/#scrips","text":"","title":"Scrips"},{"location":"scripts/git/","text":"Git \u00b6 Overview \u00b6 The script \u00b6","title":"Git"},{"location":"scripts/git/#git","text":"","title":"Git"},{"location":"scripts/git/#overview","text":"","title":"Overview"},{"location":"scripts/git/#the-script","text":"","title":"The script"},{"location":"scripts/new-ca/","text":"New CA \u00b6 Overview \u00b6 The script \u00b6","title":"New CA"},{"location":"scripts/new-ca/#new-ca","text":"","title":"New CA"},{"location":"scripts/new-ca/#overview","text":"","title":"Overview"},{"location":"scripts/new-ca/#the-script","text":"","title":"The script"},{"location":"scripts/rpt/","text":"Reverse Proxy Tracer \u00b6 Overview \u00b6 The script \u00b6","title":"Reverse Proxy Tracer"},{"location":"scripts/rpt/#reverse-proxy-tracer","text":"","title":"Reverse Proxy Tracer"},{"location":"scripts/rpt/#overview","text":"","title":"Overview"},{"location":"scripts/rpt/#the-script","text":"","title":"The script"},{"location":"scripts/system-install/","text":"System Install \u00b6 Overview \u00b6 The script \u00b6","title":"System Install"},{"location":"scripts/system-install/#system-install","text":"","title":"System Install"},{"location":"scripts/system-install/#overview","text":"","title":"Overview"},{"location":"scripts/system-install/#the-script","text":"","title":"The script"},{"location":"scripts/scanners/cen/","text":"Out-of-Band Configuration Assessment \u00b6 This script follows CIS Benchmarks guidelines for OSes and applications. List of checks \u00b6 Dependencies \u00b6 How to use \u00b6 The script \u00b6","title":"Certificates expiry notification"},{"location":"scripts/scanners/cen/#out-of-band-configuration-assessment","text":"This script follows CIS Benchmarks guidelines for OSes and applications.","title":"Out-of-Band Configuration Assessment"},{"location":"scripts/scanners/cen/#list-of-checks","text":"","title":"List of checks"},{"location":"scripts/scanners/cen/#dependencies","text":"","title":"Dependencies"},{"location":"scripts/scanners/cen/#how-to-use","text":"","title":"How to use"},{"location":"scripts/scanners/cen/#the-script","text":"","title":"The script"},{"location":"scripts/scanners/ofbca/","text":"Out-of-Band Configuration Assessment \u00b6 This script follows CIS Benchmarks guidelines for OSes and applications. List of checks \u00b6 Dependencies \u00b6 How to use \u00b6 The script \u00b6","title":"Out-of-Band Configuration Assessment"},{"location":"scripts/scanners/ofbca/#out-of-band-configuration-assessment","text":"This script follows CIS Benchmarks guidelines for OSes and applications.","title":"Out-of-Band Configuration Assessment"},{"location":"scripts/scanners/ofbca/#list-of-checks","text":"","title":"List of checks"},{"location":"scripts/scanners/ofbca/#dependencies","text":"","title":"Dependencies"},{"location":"scripts/scanners/ofbca/#how-to-use","text":"","title":"How to use"},{"location":"scripts/scanners/ofbca/#the-script","text":"","title":"The script"},{"location":"scripts/scanners/sca/","text":"Security Configuration Assessment \u00b6 This script follows CIS Benchmarks guidelines for Apache HTTP Server, Apache Tomcat, Nginx, Microsoft IIS. Can be launch remotely to check Webservers applications before are published. List of checks \u00b6 Dependencies \u00b6 How to use \u00b6 The script \u00b6","title":"Security Configuration Assessment"},{"location":"scripts/scanners/sca/#security-configuration-assessment","text":"This script follows CIS Benchmarks guidelines for Apache HTTP Server, Apache Tomcat, Nginx, Microsoft IIS. Can be launch remotely to check Webservers applications before are published.","title":"Security Configuration Assessment"},{"location":"scripts/scanners/sca/#list-of-checks","text":"","title":"List of checks"},{"location":"scripts/scanners/sca/#dependencies","text":"","title":"Dependencies"},{"location":"scripts/scanners/sca/#how-to-use","text":"","title":"How to use"},{"location":"scripts/scanners/sca/#the-script","text":"","title":"The script"},{"location":"scripts/scanners/tls/","text":"TLS/SSL \u00b6 Overview \u00b6 The script \u00b6","title":"Webserver TLS/SSL"},{"location":"scripts/scanners/tls/#tlsssl","text":"","title":"TLS/SSL"},{"location":"scripts/scanners/tls/#overview","text":"","title":"Overview"},{"location":"scripts/scanners/tls/#the-script","text":"","title":"The script"},{"location":"setups/","text":"Setups \u00b6","title":"Setups"},{"location":"setups/#setups","text":"","title":"Setups"},{"location":"setups/certbot/","text":"Certbot \u00b6 Installation \u00b6 sudo apt install certbot python3-certbot-nginx Obtaining TLS Certificate \u00b6 Attention Must have server_name domain.com www.domain.com; configured. sudo certbot --nginx -d domain.com -d www.domain.com Auto-renewal \u00b6 Check Timer Status sudo systemctl status certbot.timer Auto-renewal sudo certbot renew --dry-run SSL Labs Server Check \u00b6","title":"Certbot"},{"location":"setups/certbot/#certbot","text":"","title":"Certbot"},{"location":"setups/certbot/#installation","text":"sudo apt install certbot python3-certbot-nginx","title":"Installation"},{"location":"setups/certbot/#obtaining-tls-certificate","text":"Attention Must have server_name domain.com www.domain.com; configured. sudo certbot --nginx -d domain.com -d www.domain.com","title":"Obtaining TLS Certificate"},{"location":"setups/certbot/#auto-renewal","text":"Check Timer Status sudo systemctl status certbot.timer Auto-renewal sudo certbot renew --dry-run","title":"Auto-renewal"},{"location":"setups/certbot/#ssl-labs-server-check","text":"","title":"SSL Labs Server Check"},{"location":"setups/keepassxc-cli/","text":"Keepassxc-cli \u00b6","title":"Keepassxc-cli"},{"location":"setups/keepassxc-cli/#keepassxc-cli","text":"","title":"Keepassxc-cli"},{"location":"setups/msmtp/","text":"Msmtp \u00b6","title":"Msmtp"},{"location":"setups/msmtp/#msmtp","text":"","title":"Msmtp"},{"location":"setups/nginx/","text":"Nginx \u00b6 Installation \u00b6 sudo apt update sudo apt install nginx Configurations files \u00b6 Full Examples \u00b6 Example Configurations Default HTTP \u00b6 /etc/nginx/sites-available/default ## # Default server configuration # server { listen 80 default_server; listen [::]:80 default_server; # SSL configuration # # listen 443 ssl default_server; # listen [::]:443 ssl default_server; # # Note: You should disable gzip for SSL traffic. # See: https://bugs.debian.org/773332 # # Read up on ssl_ciphers to ensure a secure configuration. # See: https://bugs.debian.org/765782 # # Self signed certs generated by the ssl-cert package # Don't use them in a production server! # # include snippets/snakeoil.conf; root /var/www/html; # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html; server_name _; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; # proxy_pass http://localhost:8080; # proxy_http_version 1.1; # proxy_set_header Upgrade $http_upgrade; # proxy_set_header Connection 'upgrade'; # proxy_set_header Host $host; # proxy_cache_bypass $http_upgrade; } # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # include snippets/fastcgi-php.conf; # # # With php7.0-cgi alone: # fastcgi_pass 127.0.0.1:9000; # # With php7.0-fpm: # fastcgi_pass unix:/run/php/php7.0-fpm.sock; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } # Virtual Host configuration for example.com # # You can move that to a different file under sites-available/ and symlink that # to sites-enabled/ to enable it. # #server { # listen 80; # listen [::]:80; # # server_name example.com; # # root /var/www/example.com; # index index.html; # # location / { # try_files $uri $uri/ =404; # } # Custom HTTPS \u00b6 Using Let's Encrypt Obtaining TLS Certificate SSL Labs Server Check /etc/nginx/sites-available/custom ## # Default server configuration # server { listen [::]:443 ssl http2 ipv6only=on; # managed by Certbot listen 443 ssl http2; # managed by Certbot ssl_certificate /etc/letsencrypt/live/domain.com/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/domain.com/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot server_name domain.com www.domain.com; root /var/www/html; ## # Nginx Bad Bot Blocker Includes # REPO: https://github.com/mitchellkrogza/nginx-ultimate-bad-bot-blocker ## include /etc/nginx/bots.d/ddos.conf; include /etc/nginx/bots.d/blockbots.conf; ## # Security headers ## add_header X-Frame-Options \"SAMEORIGIN\"; add_header Strict-Transport-Security \"max-age=31536000; includeSubdomains; preload\"; add_header Content-Security-Policy \"default-src 'self' http: https: data: blob: 'unsafe-inline'\" always; proxy_hide_header X-Powered-By; index index.php index.html; location / { limit_except GET HEAD POST { deny all; } try_files $uri $uri/ /index.php?$query_string; } error_page 404 /custom_404.html; location = /custom_404.html { root /usr/share/nginx/html; internal; } # pass PHP scripts to FastCGI server # location ~ \\.php$ { include snippets/fastcgi-php.conf; # With php-fpm (or other unix sockets): fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; # With php-cgi (or other tcp sockets): #fastcgi_pass 127.0.0.1:9000; } } Enabling configuration files \u00b6 sudo ln -s /etc/nginx/sites-available/config_file_name /etc/nginx/sites-enabled/ Extra configuration \u00b6 Hash bucket memory problem To avoid hash bucket memory problem when adding additional server names, adjust a single value in the /etc/nginx/nginx.conf file. ... http { ... server_names_hash_bucket_size 64; ... }","title":"Nginx"},{"location":"setups/nginx/#nginx","text":"","title":"Nginx"},{"location":"setups/nginx/#installation","text":"sudo apt update sudo apt install nginx","title":"Installation"},{"location":"setups/nginx/#configurations-files","text":"","title":"Configurations files"},{"location":"setups/nginx/#full-examples","text":"Example Configurations","title":"Full Examples"},{"location":"setups/nginx/#default-http","text":"/etc/nginx/sites-available/default ## # Default server configuration # server { listen 80 default_server; listen [::]:80 default_server; # SSL configuration # # listen 443 ssl default_server; # listen [::]:443 ssl default_server; # # Note: You should disable gzip for SSL traffic. # See: https://bugs.debian.org/773332 # # Read up on ssl_ciphers to ensure a secure configuration. # See: https://bugs.debian.org/765782 # # Self signed certs generated by the ssl-cert package # Don't use them in a production server! # # include snippets/snakeoil.conf; root /var/www/html; # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html; server_name _; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; # proxy_pass http://localhost:8080; # proxy_http_version 1.1; # proxy_set_header Upgrade $http_upgrade; # proxy_set_header Connection 'upgrade'; # proxy_set_header Host $host; # proxy_cache_bypass $http_upgrade; } # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # include snippets/fastcgi-php.conf; # # # With php7.0-cgi alone: # fastcgi_pass 127.0.0.1:9000; # # With php7.0-fpm: # fastcgi_pass unix:/run/php/php7.0-fpm.sock; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } # Virtual Host configuration for example.com # # You can move that to a different file under sites-available/ and symlink that # to sites-enabled/ to enable it. # #server { # listen 80; # listen [::]:80; # # server_name example.com; # # root /var/www/example.com; # index index.html; # # location / { # try_files $uri $uri/ =404; # } #","title":"Default HTTP"},{"location":"setups/nginx/#custom-https","text":"Using Let's Encrypt Obtaining TLS Certificate SSL Labs Server Check /etc/nginx/sites-available/custom ## # Default server configuration # server { listen [::]:443 ssl http2 ipv6only=on; # managed by Certbot listen 443 ssl http2; # managed by Certbot ssl_certificate /etc/letsencrypt/live/domain.com/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/domain.com/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot server_name domain.com www.domain.com; root /var/www/html; ## # Nginx Bad Bot Blocker Includes # REPO: https://github.com/mitchellkrogza/nginx-ultimate-bad-bot-blocker ## include /etc/nginx/bots.d/ddos.conf; include /etc/nginx/bots.d/blockbots.conf; ## # Security headers ## add_header X-Frame-Options \"SAMEORIGIN\"; add_header Strict-Transport-Security \"max-age=31536000; includeSubdomains; preload\"; add_header Content-Security-Policy \"default-src 'self' http: https: data: blob: 'unsafe-inline'\" always; proxy_hide_header X-Powered-By; index index.php index.html; location / { limit_except GET HEAD POST { deny all; } try_files $uri $uri/ /index.php?$query_string; } error_page 404 /custom_404.html; location = /custom_404.html { root /usr/share/nginx/html; internal; } # pass PHP scripts to FastCGI server # location ~ \\.php$ { include snippets/fastcgi-php.conf; # With php-fpm (or other unix sockets): fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; # With php-cgi (or other tcp sockets): #fastcgi_pass 127.0.0.1:9000; } }","title":"Custom HTTPS"},{"location":"setups/nginx/#enabling-configuration-files","text":"sudo ln -s /etc/nginx/sites-available/config_file_name /etc/nginx/sites-enabled/","title":"Enabling configuration files"},{"location":"setups/nginx/#extra-configuration","text":"Hash bucket memory problem To avoid hash bucket memory problem when adding additional server names, adjust a single value in the /etc/nginx/nginx.conf file. ... http { ... server_names_hash_bucket_size 64; ... }","title":"Extra configuration"},{"location":"setups/openpgp-encrypted-password/","text":"OpenPGP Encrypted Password \u00b6","title":"OpenPGP Encrypted Password"},{"location":"setups/openpgp-encrypted-password/#openpgp-encrypted-password","text":"","title":"OpenPGP Encrypted Password"},{"location":"setups/php/","text":"PHP \u00b6","title":"PHP"},{"location":"setups/php/#php","text":"","title":"PHP"}]}